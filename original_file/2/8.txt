1
00:00:08,065 --> 00:00:12,035
接下來我們來介紹exponential back-off 的algorithm

2
00:00:12,035 --> 00:00:13,078
就是說我們說

3
00:00:13,078 --> 00:00:16,075
這個ethernet的這個網卡他

4
00:00:16,075 --> 00:00:20,015
送出去的時候呢可能會造成所謂的collision

5
00:00:20,015 --> 00:00:22,031
那發生collision之後呢

6
00:00:23,015 --> 00:00:27,005
每一個station 他就會再送一個所謂的jam signal

7
00:00:27,005 --> 00:00:31,048
把這個所謂的衝撞的這個封包 等於讓他撞得更徹底

8
00:00:31,048 --> 00:00:36,028
但是這也代表說這個封包已經沒有用了 他已經毀掉了

9
00:00:36,028 --> 00:00:40,031
那毀掉之後呢 我們到底要什麼時候再來送呢

10
00:00:40,031 --> 00:00:43,071
因為畢竟第一次封包傳送失敗的意思

11
00:00:43,071 --> 00:00:46,095
那我們希望這個封包還是可以把它成功的送出去

12
00:00:46,095 --> 00:00:50,088
所以作法就是說我們會等一個時間

13
00:00:50,088 --> 00:00:54,045
阿這個時間到底等多久呢 就是我們現在要介紹

14
00:00:54,045 --> 00:00:57,078
所謂的exponential back-off 這個back-off就是相當於說

15
00:00:57,078 --> 00:01:01,098
我這次傳送呢失敗 那我等一下會再來

16
00:01:01,098 --> 00:01:05,015
那我等多久會過來再試一次的意思

17
00:01:05,085 --> 00:01:09,068
那我們說有可能因為網路的loading很重

18
00:01:09,068 --> 00:01:12,061
所以也有可能我這次傳送失敗

19
00:01:12,061 --> 00:01:15,021
那我等待一個時間以後我重新來

20
00:01:15,021 --> 00:01:17,031
那我重新再來的時候呢

21
00:01:17,031 --> 00:01:21,015
一樣他要再一次的follow CSMA/CD

22
00:01:21,015 --> 00:01:24,011
就是每次要傳送的時候都要先聽聽看

23
00:01:24,011 --> 00:01:26,098
我們講聽聽看那個carrier sense嘛

24
00:01:26,098 --> 00:01:29,008
看看這個cable上面有沒有訊號

25
00:01:29,008 --> 00:01:31,061
如果有訊號 一樣你就必須等

26
00:01:31,061 --> 00:01:35,038
等到他等於變idle的時候呢再傳送

27
00:01:35,038 --> 00:01:38,081
那如果我們一聽 就是第二次來的時候

28
00:01:38,081 --> 00:01:42,018
一聽 這個channel上面就已經是idle的話

29
00:01:42,018 --> 00:01:43,058
那我們就送上去

30
00:01:43,058 --> 00:01:47,058
完全就是follow CSMA/CD這個protocol的方式

31
00:01:47,058 --> 00:01:52,001
那雖然是第一次衝撞 那你第二次來

32
00:01:52,001 --> 00:01:55,075
第二次來的時候呢 發現這個是idle的你就送出去

33
00:01:55,075 --> 00:01:57,095
但是呢他還是可能會衝撞

34
00:01:57,095 --> 00:02:01,085
尤其這個網路的loading如果越來越重的時候呢

35
00:02:01,085 --> 00:02:04,075
這種發生衝撞的機率呢就越來越高

36
00:02:04,075 --> 00:02:08,025
也就是說如果你第一次發生衝撞我們會等一個時間嘛

37
00:02:08,025 --> 00:02:13,011
那等了時間之後再來 如果又送出去然後又發生衝撞

38
00:02:13,011 --> 00:02:16,068
這就我們叫做連續兩次都發生衝撞

39
00:02:16,068 --> 00:02:20,071
那如果說我們這個連續衝撞的次數越多的話

40
00:02:20,071 --> 00:02:22,038
我們要談的就是說

41
00:02:22,038 --> 00:02:26,045
那我退後或著等待的時間可能就要更久一點

42
00:02:26,045 --> 00:02:29,048
因為連續衝撞就代表網路呢

43
00:02:29,048 --> 00:02:33,045
他是算是loading呢可能在某一種相當重的程度

44
00:02:33,045 --> 00:02:36,001
那連續衝撞的次數越多

45
00:02:36,001 --> 00:02:38,065
就代表網路的loading呢是越來越重

46
00:02:38,065 --> 00:02:40,065
那網路的loading越來越重就代表說

47
00:02:40,065 --> 00:02:43,031
有更多的station呢想要送封包出去

48
00:02:43,031 --> 00:02:47,071
那我們一直在等待的時間呢可能就會越等越久 越等越久

49
00:02:47,071 --> 00:02:51,035
最主要是說要避開大家同時送的這樣的機率啦

50
00:02:51,035 --> 00:02:56,085
他的做法就是說 每次連續衝撞多一次 我們等待的時間

51
00:02:56,085 --> 00:03:00,001
可能就double 就是等於說要

52
00:03:00,001 --> 00:03:02,081
等待那個時間可能就要再double

53
00:03:02,081 --> 00:03:05,005
所以變成說這個就是

54
00:03:05,005 --> 00:03:08,065
我們叫做所謂的exponential back-off的意思

55
00:03:08,065 --> 00:03:12,091
就是指說 我每一次呢衝撞多一次

56
00:03:12,091 --> 00:03:17,018
那我們這個back-off的時間呢 就要再多一倍

57
00:03:17,018 --> 00:03:20,028
所以等於意思就是說我們看一下

58
00:03:20,028 --> 00:03:24,098
下面這樣的說法就是說 那在ethernet裡面的標準裡面

59
00:03:24,098 --> 00:03:27,098
他是這樣子設計的 我們看一下

60
00:03:27,098 --> 00:03:34,005
我們說一開始呢 第一次delay

61
00:03:34,005 --> 00:03:36,051
就是我們一旦發生衝撞呢 我們剛剛提到說

62
00:03:36,051 --> 00:03:39,081
那我就要等一個時間嘛 阿這個時間到底等多久呢

63
00:03:39,081 --> 00:03:44,088
如果發生衝撞的這個station他們大家等的時間都一樣的話

64
00:03:44,088 --> 00:03:48,088
那其實下一次呢我們可以預測他也是一樣又衝撞

65
00:03:48,088 --> 00:03:50,081
因為大家等的時間都一樣嘛

66
00:03:50,081 --> 00:03:53,085
所以這個等的時間呢 必須是一個random

67
00:03:53,085 --> 00:03:56,051
他是一個類似一個亂數 random number generation

68
00:03:56,051 --> 00:03:59,005
就是大家等的時間要錯開來的意思

69
00:03:59,005 --> 00:04:00,051
但是到底要等多久呢

70
00:04:00,051 --> 00:04:04,005
我們說如果第一次衝撞的話

71
00:04:04,005 --> 00:04:06,021
我們等的時間有兩個可以選

72
00:04:06,021 --> 00:04:09,091
一個就是0 就是不等 直接就送出去

73
00:04:09,091 --> 00:04:13,055
欸不是 直接就來執行CSMA/CD啦

74
00:04:13,055 --> 00:04:16,005
我們再次強調 就每次不管你等多少時間

75
00:04:16,005 --> 00:04:21,005
時間等到了你還是要從CSMA/CD開始來

76
00:04:21,005 --> 00:04:24,051
再次的使用CSMA/CD來傳送這個封包

77
00:04:24,095 --> 00:04:28,068
好 我們說第一次delay呢 有兩個可以選擇

78
00:04:28,068 --> 00:04:32,015
一個就是0 一個就是51.2µs

79
00:04:32,015 --> 00:04:36,081
那我們說這個51.2µs就是所謂的collision window嘛

80
00:04:36,081 --> 00:04:39,035
就是一個round-trip time的時間

81
00:04:39,035 --> 00:04:40,055
就是一個collision window

82
00:04:40,055 --> 00:04:42,048
好 那第一次collision呢

83
00:04:42,048 --> 00:04:47,048
我們就在0跟51.2µs這兩個數字之間呢

84
00:04:47,048 --> 00:04:52,021
我們用亂數去挑 你可能挑到0 可能挑到51.2

85
00:04:52,021 --> 00:04:54,075
阿如果挑到51.2µs 就代表說

86
00:04:54,075 --> 00:04:59,075
你可能要等51.2µs之後呢 你再來試一次

87
00:04:59,075 --> 00:05:02,025
那我們強調 你再來試一次呢

88
00:05:02,025 --> 00:05:06,001
一樣要跑CSMA/CD的protocol 就是還是要去聽聽看

89
00:05:06,001 --> 00:05:11,001
到底現在我們講那個cable上面是busy還是idle

90
00:05:11,001 --> 00:05:13,041
那如果說我們說

91
00:05:13,041 --> 00:05:18,028
好啦不管你是挑到0或挑到51.2反正時間來了

92
00:05:18,028 --> 00:05:20,068
時間到了你就再試一次

93
00:05:20,068 --> 00:05:22,001
好那試一次呢

94
00:05:22,001 --> 00:05:26,001
你又把假設剛剛好又可以把封包丟出去 你就丟出去

95
00:05:26,001 --> 00:05:30,071
那丟出去呢假設萬一又衝撞 我們說這就是第二次衝撞

96
00:05:30,071 --> 00:05:32,025
就是同樣一個封包

97
00:05:32,025 --> 00:05:36,098
在傳送的過程當中已經發生了第二次的collision

98
00:05:36,098 --> 00:05:39,011
那如果發生第二次的collision呢

99
00:05:39,011 --> 00:05:42,011
我們這個back-off的時間呢 我們看一下

100
00:05:42,011 --> 00:05:47,048
就變成 我們可以選的這個範圍就變成更大一點

101
00:05:47,048 --> 00:05:49,045
我們剛剛提到 有一個叫做double

102
00:05:49,045 --> 00:05:54,065
就本來是第一次衝撞呢選的是0或51.2µs

103
00:05:54,065 --> 00:05:57,041
那第二次衝撞 連續第二次衝撞

104
00:05:57,041 --> 00:06:01,098
我們就是0, 51.2 變成102.4, 153.6

105
00:06:01,098 --> 00:06:08,041
事實上這個數字就是k乘上51.2 而k = 0,1,2,3

106
00:06:08,041 --> 00:06:12,028
因為我們的單位就是一個collision window嘛

107
00:06:12,028 --> 00:06:16,038
51.2我們說在ethernet裡面是有特別意義的數字

108
00:06:16,038 --> 00:06:21,065
他代表一個ethernet最大的網路 一個訊號來回的時間

109
00:06:21,065 --> 00:06:23,048
我們叫做collision window

110
00:06:23,048 --> 00:06:26,098
也就是說事實上相當於 我們第一次衝撞的話

111
00:06:26,098 --> 00:06:30,055
我們等的就是0或1 我們講0或1就是

112
00:06:30,055 --> 00:06:34,045
乘上這個k啦 乘上這個51.2µs

113
00:06:34,045 --> 00:06:38,025
也就是第一次衝撞的話 k=0或1

114
00:06:38,025 --> 00:06:42,011
那如果連續第二次衝撞 k=0,1,2,3

115
00:06:42,011 --> 00:06:47,025
在這個四個數字裡面 0,1,2,3我們取亂數

116
00:06:47,025 --> 00:06:49,081
所以第二次參加衝撞

117
00:06:49,081 --> 00:06:52,035
因為我們發生衝撞的時候 可能是兩個station

118
00:06:52,035 --> 00:06:56,025
事實上可能有更多的station 因為到底是幾個不一定

119
00:06:56,025 --> 00:06:59,098
因為有可能兩個同時送 他就會衝撞 但是兩個以上的

120
00:06:59,098 --> 00:07:02,051
三個四個五個都有可能同時衝撞

121
00:07:02,051 --> 00:07:05,028
反正參加衝撞的這種station呢

122
00:07:05,028 --> 00:07:08,015
他們就如果是都是第二次的話

123
00:07:08,015 --> 00:07:11,041
他們就在這個k=0,1,2,3這邊

124
00:07:11,041 --> 00:07:12,098
就挑一個亂數

125
00:07:12,098 --> 00:07:17,005
可能有人挑到0 有人挑到1 有人挑到2 有人挑到3

126
00:07:17,005 --> 00:07:19,038
那就各自不同的delay

127
00:07:19,038 --> 00:07:23,008
那反正每一個人的delay到了他就再重來

128
00:07:23,008 --> 00:07:27,025
啊重來就是follow 我們講的CSMA/CD的protocol

129
00:07:27,025 --> 00:07:30,001
所以有時候有的人是0有的人是3

130
00:07:30,001 --> 00:07:33,088
那這個0的人他比較早來 那送成功了他就錯開了嘛

131
00:07:33,088 --> 00:07:37,048
我們本來的目的就是希望大家即使重來的時候呢

132
00:07:37,048 --> 00:07:42,001
那個重來的時間點也要把它錯開 那一旦把它錯開

133
00:07:42,001 --> 00:07:45,001
就降低了一個再一次衝撞的機率啦

134
00:07:45,001 --> 00:07:50,041
但是也有可能是說 我們一直在衝撞 結果呢

135
00:07:50,041 --> 00:07:53,081
下一次時間到的時候 發現有人先送了

136
00:07:53,081 --> 00:07:58,008
就有一些沒有參加衝撞的station 他也有可能在

137
00:07:58,008 --> 00:08:02,055
大家都退後的過程當中 因為大家都在等待嘛 他反而先送了

138
00:08:02,055 --> 00:08:06,058
這個是CSMA/CD 這個所謂的exponential back-off algorithm

139
00:08:06,058 --> 00:08:08,038
他有一個這樣的所謂的side effect

140
00:08:08,038 --> 00:08:13,015
就是說先到的不一定能夠先送出去啦

141
00:08:13,015 --> 00:08:16,001
就是我們可能好幾個station先到

142
00:08:16,001 --> 00:08:18,001
代表他們想要先送

143
00:08:18,001 --> 00:08:21,001
可是我們都在那邊撞來撞去 我們都在退後

144
00:08:21,001 --> 00:08:23,025
結果一個比較晚到的station

145
00:08:23,025 --> 00:08:25,061
他想送的時候發現這個channel idle

146
00:08:25,061 --> 00:08:26,091
他一送他就成功了

147
00:08:26,091 --> 00:08:30,001
因為前面到了他們都在那邊撞得稀巴爛

148
00:08:30,001 --> 00:08:32,068
到後面等待更久 這是有可能的

149
00:08:32,068 --> 00:08:37,075
好我們再回到這邊說 好 那如果說第二次傳輸呢

150
00:08:37,075 --> 00:08:40,095
不管你這個亂數怎麼選0,1,2,3

151
00:08:40,095 --> 00:08:43,055
但是呢他再次送出去的時候呢

152
00:08:43,055 --> 00:08:47,015
又發生collision 我們這個叫做連續三次的collision

153
00:08:47,015 --> 00:08:50,011
那如果發生了連續三次的collision的話

154
00:08:50,011 --> 00:08:55,008
那這個一樣 我們這個還是一樣要這個back-off

155
00:08:55,008 --> 00:08:58,021
那back-off的亂數呢就變成0,1,2,3,4,5,6,7

156
00:08:58,021 --> 00:09:01,085
 就變成說 剛剛所謂的exponential就是指這裡

157
00:09:01,085 --> 00:09:06,058
因為我第一次衝撞我可以挑的有兩個亂數嘛 兩個裡面挑

158
00:09:06,058 --> 00:09:10,091
那第二次衝撞呢變成四個 第三次衝撞變成八個

159
00:09:10,091 --> 00:09:12,078
所以簡單的講就是說

160
00:09:12,078 --> 00:09:19,038
如果第三次衝撞的話 我們變成等於說是0到7啦

161
00:09:19,038 --> 00:09:22,075
這個地方0到7 那如果再往下的話呢

162
00:09:22,075 --> 00:09:25,058
所以我們用一個比較general的演算法來看

163
00:09:25,058 --> 00:09:32,065
就是如果你連續譬如說n次衝撞的話 連續n次啦

164
00:09:32,065 --> 00:09:37,031
那n就是 n=1就代表一次 n=2就代表第二次嘛

165
00:09:37,031 --> 00:09:42,015
那連續衝撞n次的話 那我們再退後的亂數呢

166
00:09:42,015 --> 00:09:50,035
這個就變成k*51.2µs  可是這個k值就是2的n次方減一

167
00:09:50,035 --> 00:09:54,001
這個是很重要的一個數字 2的n次方減一

168
00:09:54,001 --> 00:09:55,051
所以我們可以就這樣子講

169
00:09:55,051 --> 00:09:59,015
就是說 好那你如果第一次衝撞你就挑0,1嘛

170
00:09:59,015 --> 00:10:04,001
那連續第二次衝撞就是0,1,2,3 這裡面挑一個

171
00:10:04,001 --> 00:10:07,018
那如果連續三次呢 就是0,1,2,3,4,5,6,7

172
00:10:07,018 --> 00:10:11,008
那如果連續四次的話呢就是0,1,2,3,4,5,6,7到15

173
00:10:11,008 --> 00:10:13,065
就是2的n次方-1這樣子

174
00:10:13,065 --> 00:10:16,058
那這樣一直衝 每次衝每次衝撞 連續的

175
00:10:16,058 --> 00:10:19,078
那最多最多呢 最多最多ethernet

176
00:10:19,078 --> 00:10:21,041
他的標準裡面最多十六次

177
00:10:21,041 --> 00:10:24,015
也就是說我這個封包如果送出去呢

178
00:10:24,015 --> 00:10:26,061
想要送 第一次衝撞我delay

179
00:10:26,061 --> 00:10:30,021
那delay完之後呢再來 再送出去又collision

180
00:10:30,021 --> 00:10:33,048
我就再等 再collision 再等 再collision 再等

181
00:10:33,048 --> 00:10:36,031
連續十六次都發生collision

182
00:10:36,031 --> 00:10:41,035
那這個網路幾乎是已經算是不太可能送成功

183
00:10:41,035 --> 00:10:42,078
因為他loading實在是太重

184
00:10:42,078 --> 00:10:45,045
這個時候我就會放棄

185
00:10:45,045 --> 00:10:47,091
就是說ethernet裡面他的網卡呢

186
00:10:47,091 --> 00:10:50,091
是會盡力地把這個封包送出去

187
00:10:50,091 --> 00:10:55,091
但是這個盡力 就是連續衝撞16次 他就放棄

188
00:10:55,091 --> 00:10:57,045
最多最多16次

189
00:10:57,045 --> 00:11:04,041
但是如果說我們講 16次那我代表說我要delay的時間變成2的16次方-1

190
00:11:04,041 --> 00:11:09,085
哇那這個時間很長啊 60000多個這個單位乘上51.2µs

191
00:11:09,085 --> 00:11:10,058
這個太長了

192
00:11:10,058 --> 00:11:14,035
所以我們這個等待的時間 我們講2的n次方-1

193
00:11:14,035 --> 00:11:17,055
這個n他有一個上限的值 就是10

194
00:11:17,055 --> 00:11:25,075
10的意思就是說 0到1023啦 就是我們說在delay呢在挑亂數的時候

195
00:11:25,075 --> 00:11:29,085
最多是0到1023之間挑一個

196
00:11:29,085 --> 00:11:31,085
就是說我如果連續衝撞10次

197
00:11:31,085 --> 00:11:34,045
好那我就挑0到1023

198
00:11:34,045 --> 00:11:39,088
那我如果衝撞第11次 還是0到1023

199
00:11:39,088 --> 00:11:41,088
裡面挑一個數字 亂數

200
00:11:41,088 --> 00:11:48,045
第12次呢也是0到1023 第13次也是0到1023 第14次15次都一樣

201
00:11:48,045 --> 00:11:52,008
到了第16次 又collision 我就放棄 我就不送了

202
00:11:52,008 --> 00:11:54,068
變成說 我們每次發生collision

203
00:11:54,068 --> 00:12:00,038
就會用double的這個範圍呢來挑那個random的時間

204
00:12:00,038 --> 00:12:01,088
每次double 每次double

205
00:12:01,088 --> 00:12:06,091
那每次double 我們在這個結果就是一個我們叫做exponential

206
00:12:06,091 --> 00:12:12,038
他就是一個指數的函數 因為我們每次都是double的話他就是一個指數函數

207
00:12:12,038 --> 00:12:15,078
好所以我們再做一次這樣的summary

208
00:12:15,078 --> 00:12:19,078
就是CSMA/CD protocol本身他的主要的特色

209
00:12:19,078 --> 00:12:22,015
我們再講 再等於是做一個重點整理

210
00:12:22,015 --> 00:12:25,048
第一個 在傳輸之前 我們說

211
00:12:25,048 --> 00:12:27,095
before transmission呢 我們會做carrier sense

212
00:12:27,095 --> 00:12:33,091
再送之前要聽聽看 這個cable呢到底是idle還是busy

213
00:12:33,091 --> 00:12:37,068
好 再假設是這個idle我們就送出去嘛

214
00:12:37,068 --> 00:12:43,028
那在傳送的過程當中 我們還是要繼續的聽

215
00:12:44,008 --> 00:12:47,018
我們講 我們叫做carrier sense while transmission

216
00:12:47,018 --> 00:12:52,028
就是說即使我們可以把封包送出去 可在傳送的過程當中呢

217
00:12:52,028 --> 00:12:55,008
還是要繼續的聽 為什麼要繼續的聽呢

218
00:12:55,008 --> 00:12:59,038
因為我們要偵測到底我們的封包有沒有發生所謂的collision

219
00:12:59,038 --> 00:13:02,078
那collision就是說兩個或兩個以上的station

220
00:13:02,078 --> 00:13:06,015
如果同時傳送的話 他們的訊號就會疊在一起

221
00:13:06,015 --> 00:13:08,048
那這個就會造成封包的錯誤

222
00:13:08,048 --> 00:13:13,015
好 那如果我們發生了collision 我就會把這個封包停掉

223
00:13:13,015 --> 00:13:15,098
就不送 而且甚至我會送一個jam signal

224
00:13:15,098 --> 00:13:19,091
讓他撞得更嚴重一點 然後同時就把封包就停掉

225
00:13:19,091 --> 00:13:23,068
那停掉的話這個封包就算是傳送失敗

226
00:13:23,068 --> 00:13:26,051
那我們要什麼時候再回來呢

227
00:13:26,051 --> 00:13:28,058
那我們說再回來就是所謂的back-off

228
00:13:28,058 --> 00:13:33,055
就是我會再一次的回來嘗試把這個封包再送一次

229
00:13:33,055 --> 00:13:36,095
那這個back-off本身 他的delay多久呢

230
00:13:36,095 --> 00:13:40,025
到底要等多久再回來？我們說這是一個random delay

231
00:13:40,025 --> 00:13:43,055
他是一個亂數 那這個random delay呢

232
00:13:43,055 --> 00:13:46,085
他是有剛剛提到那個 exponential back-off algorithm

233
00:13:46,085 --> 00:13:53,098
他是每次第一次衝撞 我delay呢就是0,1挑一個數字 乘上51.2µs

234
00:13:53,098 --> 00:13:59,098
那如果再第二次衝撞 我就0,1,2,3挑一個亂數 乘上51.2µs

235
00:13:59,098 --> 00:14:03,098
那第三次就0,1,2,3,4,5,6,7 就是exponential

236
00:14:03,098 --> 00:14:05,091
這樣的挑選那個亂數

237
00:14:05,091 --> 00:14:08,048
好那我們剛剛提到說第一個

238
00:14:08,048 --> 00:14:12,051
在傳送之前要聽聽看有沒有carrier嘛

239
00:14:12,051 --> 00:14:16,005
那如果是idle你就送 但如果是busy的話

240
00:14:16,005 --> 00:14:19,068
我們說如果這個channel sense是busy 代表現在有人正在送

241
00:14:19,068 --> 00:14:24,008
那有人正在送 你就不能送啊 你一送就是撞在一起了

242
00:14:24,008 --> 00:14:27,088
所以如果現在發現已經有人在送 就所謂的busy

243
00:14:27,088 --> 00:14:34,005
那我們就繼續聽 我們就去聽 聽到等到他變成idle的時候再送

244
00:14:34,005 --> 00:14:37,028
所以說如果channel是busy 我們就會稍微延後

245
00:14:37,028 --> 00:14:41,031
等到這個channel變成idle之後才送

246
00:14:41,031 --> 00:14:44,045
那我們也提到說什麼叫做collision window

247
00:14:44,045 --> 00:14:47,095
就是我們要偵測我們自己丟出去的封包

248
00:14:47,095 --> 00:14:49,088
到底有沒有發生collision

249
00:14:49,088 --> 00:14:54,055
那我們要偵測多久 至少你要偵測呢 一個round-trip time

250
00:14:54,055 --> 00:14:59,011
因為說 我們說發生衝撞最長的時間

251
00:14:59,011 --> 00:15:04,011
需要偵測的時間 最長就是一個訊號來回的時間

252
00:15:04,011 --> 00:15:07,008
就是因為發生衝撞的這個兩個station呢

253
00:15:07,008 --> 00:15:10,071
他們在網路的最兩端啦 最遠的兩端

254
00:15:10,071 --> 00:15:14,051
那這個訊號的來回 我們叫做一個所謂的collision window

255
00:15:14,051 --> 00:15:17,008
就是所謂的round-trip time 一個slow time

256
00:15:17,008 --> 00:15:20,075
好 那在這個ethernet的標準裡面呢

257
00:15:20,075 --> 00:15:25,005
這個slow time呢他是設定為51.2µs

258
00:15:25,005 --> 00:15:28,091
所以51.2是一個特別有意義的數字

259
00:15:28,091 --> 00:15:34,075
那我們再提到說 那我們到底在發生collision的時候怎麼處理呢

260
00:15:34,075 --> 00:15:39,058
我們說collision的訊號是由這個physical layer所送出去

261
00:15:39,058 --> 00:15:43,048
那他會送出一個jam 我們說如果發生了collision

262
00:15:43,048 --> 00:15:47,005
偵測到collision的話 我們會再送出一個jam signal

263
00:15:47,005 --> 00:15:51,031
這個jam signal的目的 我們說叫做collision enforcement

264
00:15:51,088 --> 00:15:55,048
就是強迫他撞得更嚴重一點

265
00:15:55,048 --> 00:15:59,031
那撞了之後呢 我們就開始所謂的back-off

266
00:15:59,031 --> 00:16:02,085
因為我們等一下會再來嘗試把封包送出去

267
00:16:02,085 --> 00:16:05,058
那這個嘗試的這個時間等待呢

268
00:16:05,058 --> 00:16:11,001
我們叫做所謂的binary exponential back-off的algorithm

269
00:16:11,001 --> 00:16:14,078
那我們剛剛就是提到說 每次衝撞呢

270
00:16:14,078 --> 00:16:18,071
我們假設n是連續衝撞的次數

271
00:16:18,071 --> 00:16:21,015
那我們剛剛也提到 n要小於等於16

272
00:16:21,015 --> 00:16:23,075
就是說連續衝撞超過16次

273
00:16:23,075 --> 00:16:27,018
我們基本上就不送了 這個封包我們就不送了

274
00:16:27,018 --> 00:16:30,098
因為這個時候代表網路呢 是非常非常的壅擠

275
00:16:30,098 --> 00:16:34,008
你想送其實也 應該也送不出去了啦

276
00:16:34,008 --> 00:16:36,028
所以n超過16呢就不送

277
00:16:36,028 --> 00:16:40,095
那我們剛剛也提到說 我們在等待的這個random number呢

278
00:16:40,095 --> 00:16:43,071
是我們講2的n次方-1嘛

279
00:16:43,071 --> 00:16:49,095
阿那個k呢 我們就會從minimum n跟10來挑一個數字

280
00:16:49,095 --> 00:16:53,088
ok 也就是說 如果連續衝撞的次數呢 小於10

281
00:16:53,088 --> 00:16:58,011
小於10的話 那我們就是2的n次方-1

282
00:16:58,011 --> 00:17:03,031
0到2的n次方-1來挑那個亂數 但是如果n大於10了

283
00:17:03,031 --> 00:17:06,058
剛提到連續衝撞已經11,12,13,14,15了

284
00:17:06,058 --> 00:17:09,091
但是我們在挑那個random number的時候

285
00:17:09,091 --> 00:17:15,055
k呢還是用10嘛 最多我們挑的那個亂數的這個範圍

286
00:17:15,055 --> 00:17:24,038
就是0到1023 就是這個k值呢 我們取的是10跟n的這個minimum

287
00:17:24,038 --> 00:17:28,055
那這個也叫做truncation啦 就是我們把那個

288
00:17:28,055 --> 00:17:33,085
k把這個n大於10的 都把它切掉的意思

289
00:17:33,085 --> 00:17:37,031
就是n如果大於10 n=11,12,13,14,15

290
00:17:37,031 --> 00:17:41,055
我們都把他用10來處理 所以這個叫所謂的truncation

291
00:17:41,055 --> 00:17:44,065
好 那我們挑的這個random number的delay

292
00:17:44,065 --> 00:17:51,018
我們叫做r 這個r呢就是在介於0跟2的k次方之間

293
00:17:51,018 --> 00:17:54,065
那我們剛剛提到就是說我們每次發生collision

294
00:17:54,065 --> 00:17:59,011
那我們再random delay 啊這個delay的時間

295
00:17:59,011 --> 00:18:04,078
就是0到2的k次方 這樣子來挑一個數字的意思

296
00:18:07,005 --> 00:18:10,095
好那我們剛也提到說 在ethernet裡面呢

297
00:18:10,095 --> 00:18:16,051
我們的一個slow time 一個slow time就是51.2µs

298
00:18:16,051 --> 00:18:21,035
我們剛剛也提到說 這非常非常重要的 非常有意義的數字

299
00:18:21,035 --> 00:18:27,005
在ethernet裡面 一個slow time 就是一個訊號來回的時間 是51.2µs

300
00:18:27,005 --> 00:18:31,008
那最後我們提一下 說我們剛剛提到前面這個方法

301
00:18:31,008 --> 00:18:35,085
叫做所謂的binary exponential back-off的algorithm

302
00:18:35,085 --> 00:18:41,018
就是說我們如果發生衝撞的話呢 我們會等待一段時間再來嘗試

303
00:18:41,018 --> 00:18:48,001
而且連續衝撞的次數如果越多 我們等待的時間就會可能就越久

304
00:18:48,001 --> 00:18:51,058
因為這個亂數啦 就是那個可能會撞得越嚴重

305
00:18:51,058 --> 00:18:55,015
可能就會等待的越久 那這樣的一個方法

306
00:18:55,015 --> 00:18:58,098
我們叫做所謂的binary exponential back-off的algorithm

307
00:18:58,098 --> 00:19:03,015
那這樣的algorithm呢 他有一個所謂的缺點就是說

308
00:19:03,015 --> 00:19:08,061
他會出現一個現象叫作 last-in-first-out的這樣的effect

309
00:19:08,061 --> 00:19:12,038
last-in-first-out我們在資料結構裡面很清楚就是說

310
00:19:12,038 --> 00:19:16,058
最後進來的first out 就是反而先送出去

311
00:19:16,058 --> 00:19:20,058
這是我們剛提到就是說 我可能有一堆的這個工作站

312
00:19:20,058 --> 00:19:25,005
那他們都想送封包 那他們都比較早進來想要送

313
00:19:25,005 --> 00:19:27,008
結果又collision 所以就退後嘛

314
00:19:27,008 --> 00:19:30,041
那他們在退後 在等待的過程當中

315
00:19:30,041 --> 00:19:33,028
反而有另外一個station呢他比較晚到

316
00:19:33,028 --> 00:19:39,015
可是她一聽這個channel呢是idle的 他就送出去了

317
00:19:39,015 --> 00:19:43,058
剛好他就送成功了 因為剛剛發生衝撞的那一群

318
00:19:43,058 --> 00:19:48,008
他們都在back-off 結果我比較後到

319
00:19:48,008 --> 00:19:51,041
我反而先送 所以他會有一個這個現象 就是說

320
00:19:51,041 --> 00:19:55,021
先到的不見得先送 那後到的可能會先送

321
00:19:55,021 --> 00:19:58,005
所以他有所謂的last-in-first-out的這樣的效果

322
00:19:58,005 --> 00:20:01,075
這樣的效果當然 就我們講 以公平性來講不是很公平

323
00:20:01,075 --> 00:20:05,088
但是這是沒有辦法 因為這個演算法就是這樣子設計

324
00:20:05,088 --> 00:20:07,088


