1
00:00:08,098 --> 00:00:10,071
好接下來我們就來看

2
00:00:10,071 --> 00:00:13,085
所謂的CSMA/CD到底怎麼運作的

3
00:00:13,085 --> 00:00:16,068
那我們說CSMA/CD就是所謂的

4
00:00:16,068 --> 00:00:20,078
carrier sense multiple access with collision detection

5
00:00:20,078 --> 00:00:24,051
就是說multiple access就是說 我們現在呢

6
00:00:24,051 --> 00:00:29,075
有一堆或者一組的這個所謂的這個網卡或者工作站呢

7
00:00:29,075 --> 00:00:33,055
他會share這一個所謂的link

8
00:00:33,055 --> 00:00:38,038
就是在一個網段上面 會有多個我們叫multiple access

9
00:00:38,038 --> 00:00:40,058
多個電腦 然後同時呢

10
00:00:40,058 --> 00:00:44,035
要在這個cable上面呢做這個所謂的封包的傳送

11
00:00:44,035 --> 00:00:46,078
那carrier sense就代表是說

12
00:00:46,078 --> 00:00:51,075
我們會去偵測一下這個cable上面到底有沒有訊號

13
00:00:51,075 --> 00:00:55,085
那他的結果就是 可能是一個是idle

14
00:00:55,085 --> 00:00:59,005
代表說上面呢現在是沒有訊號的

15
00:00:59,005 --> 00:01:00,095
另外一個就所謂的busy

16
00:01:00,095 --> 00:01:05,038
代表說現在已經有封包呢正在上面傳送

17
00:01:05,038 --> 00:01:06,075
這是所謂的carrier sense

18
00:01:06,075 --> 00:01:11,078
那collision detection就是說 我們會讓這個封包

19
00:01:11,078 --> 00:01:16,075
如果說發現說 這個是idle 我們就把封包丟上去

20
00:01:16,075 --> 00:01:19,068
那丟上去的同時我們會繼續聽喔

21
00:01:19,068 --> 00:01:22,068
因為至少我要 因為我們剛剛提到

22
00:01:22,068 --> 00:01:24,088
我們的訊號送到這個cable之後呢

23
00:01:24,088 --> 00:01:27,075
他就會廣播 他就會往兩邊跑

24
00:01:27,075 --> 00:01:31,031
那同時我們也會把它收回來 所以我會一邊送

25
00:01:31,031 --> 00:01:34,078
注意到 我們會一邊送一邊聽

26
00:01:34,078 --> 00:01:36,071
因為我要收回來一邊聽啦

27
00:01:36,071 --> 00:01:39,048
那聽的時候 如果說我沒有collision

28
00:01:39,048 --> 00:01:41,018
我聽到的就是我自己的封包

29
00:01:41,018 --> 00:01:44,005
那是很乾淨的 但如果發生了collision

30
00:01:44,005 --> 00:01:47,081
我聽到的這個內容就變成說 他已經是變成雜訊了

31
00:01:47,081 --> 00:01:51,088
因為封包的重疊啦 或者抵消讓我收到的

32
00:01:51,088 --> 00:01:56,055
聽到的這個內容已經跟我當時送出去的是不一樣的

33
00:01:56,055 --> 00:02:00,055
我們就是說 這個封包可能就發生了所謂的collision

34
00:02:00,055 --> 00:02:03,085
所以我有一個這個collision detection的機制

35
00:02:03,085 --> 00:02:06,091
我可以知道說 我送出去的封包

36
00:02:06,091 --> 00:02:10,091
到底有沒有跟別人的封包撞在一起

37
00:02:10,091 --> 00:02:16,018
那我們說 當一個這個網卡呢 發現到說

38
00:02:16,018 --> 00:02:19,048
這個cable本身是所謂的idle

39
00:02:19,048 --> 00:02:21,025
這個line如果是idle的話

40
00:02:21,025 --> 00:02:24,065
我們說我們就立刻把封包丟出去

41
00:02:24,065 --> 00:02:27,075
那如果我發現說 這個cable上面呢

42
00:02:27,075 --> 00:02:32,065
現在是busy的 代表說現在呢已經有封包正在上面傳送

43
00:02:32,065 --> 00:02:36,005
那我就不能送啊 因為你送出去就跟人家撞在一起了

44
00:02:36,005 --> 00:02:39,075
所以我就會等一下 那等到什麼時候呢

45
00:02:39,075 --> 00:02:43,045
等到這個上面的這個封包送完

46
00:02:43,045 --> 00:02:45,081
送完之後呢 我就立刻送出去

47
00:02:45,081 --> 00:02:47,091
這個是他的做法 那我們說

48
00:02:47,091 --> 00:02:49,091
這種方法呢 我們叫做

49
00:02:49,091 --> 00:02:53,091
有一個滿有名的這個稱呼啦

50
00:02:53,091 --> 00:02:57,025
叫做1-persistent的protocol

51
00:02:57,025 --> 00:02:59,091
這個 我們叫做1-persistent

52
00:02:59,091 --> 00:03:02,061
1-persistent的意思就是說

53
00:03:02,061 --> 00:03:07,021
當我們發現這個channel呢是busy的時候

54
00:03:07,021 --> 00:03:09,098
我們剛剛提到 我們會繼續的監聽他嘛

55
00:03:09,098 --> 00:03:12,038
監聽到他變成idle

56
00:03:12,038 --> 00:03:16,035
就是他把這個封包送完 那變成idle之後

57
00:03:16,035 --> 00:03:20,071
你有多少的機率開始送你的封包

58
00:03:20,071 --> 00:03:23,045
這個叫做p-persistent

59
00:03:23,045 --> 00:03:28,025
p 就是說如果 等於說我們一開始這樣

60
00:03:28,025 --> 00:03:30,038
就是說我們去sense的時候

61
00:03:30,038 --> 00:03:35,028
我們假設這個是正在傳送的封包 正在送的封包

62
00:03:35,028 --> 00:03:36,098
然後我們在這個時間點

63
00:03:36,098 --> 00:03:39,098
去想要送 所以我就發現到說

64
00:03:39,098 --> 00:03:42,065
這個channel上面呢現在是busy

65
00:03:42,065 --> 00:03:44,068
因為有封包正在送

66
00:03:44,068 --> 00:03:46,068
然後我就繼續聽 就繼續聽

67
00:03:46,068 --> 00:03:49,081
聽到這個時間點 就發現說結束了

68
00:03:49,081 --> 00:03:52,078
就這個前面這個封包已經送完了

69
00:03:52,078 --> 00:03:55,065
那送完之後呢代表他是idle啦

70
00:03:55,065 --> 00:03:58,041
那idle呢你是不是一定要把它送出去呢

71
00:03:58,041 --> 00:04:01,088
那你可以看如果說我這邊有另外一個人在這邊聽

72
00:04:01,088 --> 00:04:03,078
另外有一個人在這邊聽

73
00:04:03,078 --> 00:04:09,005
代表說在這個前面一個封包在傳送的這個過程當中呢

74
00:04:09,005 --> 00:04:13,011
有三個網卡 或三個station呢

75
00:04:13,011 --> 00:04:15,071
他們都想送 他們都來聽

76
00:04:15,071 --> 00:04:17,075
發現通通都是busy

77
00:04:17,075 --> 00:04:20,038
好那如果按照我們的做法就是說

78
00:04:20,038 --> 00:04:25,038
這三個都會聽到說這個封包呢在這個時間點結束了

79
00:04:25,038 --> 00:04:28,058
那如果這三個通通把他丟出去

80
00:04:28,058 --> 00:04:30,021
他這三個就是collision

81
00:04:30,021 --> 00:04:35,011
就是說我們聽到一個這個封包送完之後

82
00:04:35,011 --> 00:04:40,055
你有馬上送出去的機率我們叫p啦 到底有多大

83
00:04:40,055 --> 00:04:44,065
那p等於1就是所謂的1-persistent

84
00:04:44,065 --> 00:04:48,055
啊如果說p不等於1 我們就叫做p-persistent

85
00:04:48,055 --> 00:04:53,018
譬如說我可以p 譬如說假設等於0.2

86
00:04:53,018 --> 00:04:58,055
的意思就是說 當我發現前面一個封包送完之後呢

87
00:04:58,055 --> 00:05:02,008
我可以把封包丟出去的機率呢是0.2

88
00:05:02,008 --> 00:05:04,051
這個你也要錯開

89
00:05:04,051 --> 00:05:06,071
等於是說在一個封包結束之後

90
00:05:06,071 --> 00:05:09,078
可能會有一些工作站呢在這邊等著要送

91
00:05:09,078 --> 00:05:12,065
那如果我p等於1的話

92
00:05:12,065 --> 00:05:16,045
只要有兩個或兩個以上的人在這邊等

93
00:05:16,045 --> 00:05:19,035
他就已經一定會collision 因為大家都把他送出去

94
00:05:19,035 --> 00:05:22,015
但是如果你用p的概念的話

95
00:05:22,015 --> 00:05:25,018
就有點像我就把它分散機會了嘛

96
00:05:25,018 --> 00:05:29,088
有人送出去的這個collision的機會就會稍微降低一點啦

97
00:05:29,088 --> 00:05:32,005
所以我們就是說 因為

98
00:05:32,005 --> 00:05:37,015
在這個CSMA/CD或者這個ethernet的網路的架構之下

99
00:05:37,015 --> 00:05:42,021
我們說他是沒有centralized control

100
00:05:42,021 --> 00:05:45,071
就是說大家都是一個獨立的電腦

101
00:05:45,071 --> 00:05:50,028
大家上面有一個晶片 大家都用CSMA/CD

102
00:05:50,028 --> 00:05:53,095
送之前都去聽聽看 如果是idle你就送

103
00:05:53,095 --> 00:05:56,001
如果是busy呢你就等

104
00:05:56,001 --> 00:05:58,078
等到他結束呢 就把他送上去

105
00:05:58,078 --> 00:06:01,015
也就是說這是一個分散式的方法

106
00:06:01,015 --> 00:06:04,075
沒有一個集中的math來告訴我們說誰

107
00:06:04,075 --> 00:06:07,038
或者哪一個網卡在什麼時候可以送

108
00:06:07,038 --> 00:06:10,098
就是說如果有兩個或兩個以上的電腦

109
00:06:10,098 --> 00:06:13,055
他們只要一聽是idle的話

110
00:06:13,055 --> 00:06:15,095
他們就會同時傳送

111
00:06:15,095 --> 00:06:19,038
這個同時傳送就會造成所謂的collision

112
00:06:19,038 --> 00:06:24,075
就是不管是說 這兩個或兩個以上

113
00:06:24,075 --> 00:06:29,021
他發現說這個線呢 現在是idle的

114
00:06:29,021 --> 00:06:31,095
他們就會同時送 這個發生collision

115
00:06:31,095 --> 00:06:36,068
或者他們去看 發現說現在cable上面其實是busy的

116
00:06:36,068 --> 00:06:38,031
可是因為我們剛剛提到

117
00:06:38,031 --> 00:06:42,001
他是1-persistent 所以如果有兩個以上發現

118
00:06:42,001 --> 00:06:45,051
這個線呢現在其實很忙碌 兩個都會繼續聽

119
00:06:45,051 --> 00:06:50,018
聽到這兩個上面的訊號呢變成idle

120
00:06:50,018 --> 00:06:53,038
送完了嘛 那兩個呢都會把它送出來

121
00:06:53,038 --> 00:06:55,031
那兩個都會把它送出來呢

122
00:06:55,031 --> 00:06:58,038
他一樣 變成說他如果發現說

123
00:06:58,038 --> 00:07:03,018
去監聽等這個線呢 變成idle

124
00:07:03,018 --> 00:07:05,085
那變成idle之後呢 一樣

125
00:07:05,085 --> 00:07:08,061
他就還是會把他送出去啦

126
00:07:08,061 --> 00:07:10,048
結果還是造成這個collision

127
00:07:10,048 --> 00:07:13,055
好 那當這個發生的時候呢

128
00:07:13,055 --> 00:07:17,078
我們就說這個時候網路呢出現了叫做collision的現象

129
00:07:17,078 --> 00:07:21,035
因為有兩個或兩個以上的這個封包呢

130
00:07:21,035 --> 00:07:24,005
同時送到這個線路上面來

131
00:07:24,005 --> 00:07:25,045
阿就是所謂的collision

132
00:07:25,045 --> 00:07:28,061
好那因為我們剛剛提到ethernet本身

133
00:07:28,061 --> 00:07:32,055
就CSMA/CD他有support collision detection

134
00:07:32,055 --> 00:07:35,005
因為他有支持這樣的功能

135
00:07:35,005 --> 00:07:39,011
也就是說 一個這個傳送的人

136
00:07:39,011 --> 00:07:43,048
他在傳送的過程當中 他可以知道說

137
00:07:43,048 --> 00:07:47,081
是不是有發生collision 就他一邊送他會一邊聽啦

138
00:07:47,081 --> 00:07:49,091
那如果有發生collision的話

139
00:07:49,091 --> 00:07:53,028
他是知道的 好那接下來就是說

140
00:07:53,028 --> 00:07:55,041
如果真的發生了collision啦

141
00:07:55,041 --> 00:07:58,038
那我也知道啦 因為我有偵測的機制

142
00:07:58,038 --> 00:08:02,078
那我會做什麼？ 就是說我一邊送一邊聽

143
00:08:02,078 --> 00:08:06,025
阿可能這個送了一段時間之後呢

144
00:08:06,025 --> 00:08:09,015
發現collision了 那我們會做什麼

145
00:08:09,015 --> 00:08:11,061
我們發生collision之後我們做一件事情

146
00:08:11,061 --> 00:08:13,061
就是說既然發生collision了

147
00:08:13,061 --> 00:08:16,001
那這個封包已經沒有用了

148
00:08:16,001 --> 00:08:17,081
那既然沒有用了

149
00:08:17,081 --> 00:08:20,098
我就要讓所有人知道說這個封包沒有用了

150
00:08:20,098 --> 00:08:24,008
那作法就是說我就再送一個

151
00:08:24,008 --> 00:08:27,088
我們叫做32-bit的這個jamming sequence

152
00:08:27,088 --> 00:08:31,005
jamming就是一般所謂的果醬

153
00:08:31,005 --> 00:08:34,041
就是說既然這個封包已經跟別人衝撞了

154
00:08:34,041 --> 00:08:37,028
不管是衝撞一個bit兩個bit 反正封包已經沒有用了

155
00:08:37,028 --> 00:08:38,018
可是呢

156
00:08:38,018 --> 00:08:42,011
我要讓所有的這個網卡都知道這個封包已經沒有用了

157
00:08:42,011 --> 00:08:46,091
所以我就再送32-bit把他打得更稀巴爛 變成說

158
00:08:46,091 --> 00:08:49,078
你一定偵測出來 這個封包一定沒有用

159
00:08:49,078 --> 00:08:52,051
免得說 如果只是衝撞一小部分

160
00:08:52,051 --> 00:08:54,078
別人還誤判 還把它收起來

161
00:08:54,078 --> 00:08:56,081
就既然這個封包已經collision了

162
00:08:56,081 --> 00:08:58,055
就讓他既然已經衝撞

163
00:08:58,055 --> 00:09:00,095
就讓他撞得更徹底的意思

164
00:09:00,095 --> 00:09:03,048
所以我一旦發現這個封包是衝撞的

165
00:09:03,048 --> 00:09:07,028
我就再送32-bit 我們就叫jamming的sequence

166
00:09:07,028 --> 00:09:09,095
讓他這個衝得更嚴重

167
00:09:09,095 --> 00:09:12,045
保證說所有的工作站

168
00:09:12,045 --> 00:09:17,001
所有的網卡都會偵測到這個問題啦

169
00:09:17,001 --> 00:09:19,085
這個就是我們講如果發生了collision

170
00:09:19,085 --> 00:09:23,028
他就會做一個這個所謂的jamming的signal

171
00:09:23,028 --> 00:09:27,031
強制把他送上去 把這個封包呢就徹底的把它打爛掉

172
00:09:27,031 --> 00:09:31,088
那我們就是說 那一個這個網卡本身最少

173
00:09:31,088 --> 00:09:35,081
他會送多少個bit到這個網路上面去

174
00:09:35,081 --> 00:09:39,011
我們說 因為一個封包開始送的時候呢

175
00:09:39,011 --> 00:09:41,025
一定會送一個叫做preamble

176
00:09:41,025 --> 00:09:42,048
我們剛剛有提到

177
00:09:42,048 --> 00:09:47,068
preamble呢是64個bit的101010這樣子嘛

178
00:09:47,068 --> 00:09:50,008
好 那最少最少我們就是說

179
00:09:50,008 --> 00:09:53,041
他送上去呢就是說有可能就是這兩個station

180
00:09:53,041 --> 00:09:57,068
他們就在隔壁 兩個工作站非常非常靠近

181
00:09:57,068 --> 00:10:01,065
那兩個幾乎同時呢去偵測到說

182
00:10:01,065 --> 00:10:06,001
你這個線路是idle的 然後他就兩個同時送上去

183
00:10:06,001 --> 00:10:08,071
兩個一同時送上去呢 就馬上collision

184
00:10:08,071 --> 00:10:11,035
因為他們在非常非常的靠近

185
00:10:11,035 --> 00:10:15,038
所以這兩個station把這個所謂的封包一丟上去

186
00:10:15,038 --> 00:10:19,035
在前面的preamble呢就撞在一起了 那撞在一起之後

187
00:10:19,035 --> 00:10:21,035
兩邊就全部送這個jamming

188
00:10:21,035 --> 00:10:23,095
因為他知道這個撞在一起了嘛

189
00:10:23,095 --> 00:10:29,081
所以我們說 一個網卡他最短最短送上去的

190
00:10:29,081 --> 00:10:32,005
就會到變成是96-bit

191
00:10:32,005 --> 00:10:36,001
因為他第一個要先送64-bit的preamble

192
00:10:36,001 --> 00:10:40,045
然後發生collision 他立刻送32-bit的jamming

193
00:10:40,045 --> 00:10:42,085
就變成說這個一加起來就96-bit

194
00:10:42,085 --> 00:10:45,098
這是最短最短 ethernet上面會發生最短

195
00:10:45,098 --> 00:10:48,055
那這種frame我們就一般叫做runt frame

196
00:10:48,055 --> 00:10:51,071
也就是說他是只有96個bits

197
00:10:51,071 --> 00:10:55,038
那這個case就是說 這兩個工作站呢

198
00:10:55,038 --> 00:11:00,095
要非常的靠近 要非常非常靠近 才有辦法用這麼短的

199
00:11:00,095 --> 00:11:04,091
因為他只要距離遠一點的話 你就不只送64-bit

200
00:11:04,091 --> 00:11:06,015
因為距離越遠

201
00:11:06,015 --> 00:11:11,018
你要衝撞的話就要花更長的時間才會撞在一起

202
00:11:11,018 --> 00:11:16,028
因為那個訊號在這個cable上面跑的時候呢 也要花時間

203
00:11:16,028 --> 00:11:18,011
所以距離越遠的話

204
00:11:18,011 --> 00:11:22,048
訊號上去就要更久的時間 這個訊號才會撞在一起

205
00:11:22,048 --> 00:11:25,025
我們講訊號要立刻撞在一起

206
00:11:25,025 --> 00:11:27,065
就是這兩個工作站呢 非常的靠近

207
00:11:27,065 --> 00:11:31,018
一送上去馬上就撞在一起 就他們在隔壁啦

208
00:11:31,018 --> 00:11:35,098
好 那我們說 如果兩個工作站呢是比較遠的話

209
00:11:35,098 --> 00:11:39,068
那因為訊號傳輸要時間嘛

210
00:11:39,068 --> 00:11:42,018
所以就比較不會說立刻就衝撞在一起

211
00:11:42,018 --> 00:11:45,061
會比較花長一點的時間才會撞在一起啦

212
00:11:45,061 --> 00:11:49,098
但是呢我們還是有辦法判斷他到底有沒有發生衝撞

213
00:11:49,098 --> 00:11:53,035
那底下我們來介紹一個很重要的概念

214
00:11:53,035 --> 00:11:54,095
就是所謂叫做collision window

215
00:11:54,095 --> 00:11:58,035
就是說我們在ethernet裡面

216
00:11:58,035 --> 00:12:01,085
我們會先聽聽看這個封包

217
00:12:01,085 --> 00:12:06,011
在送的時候呢 這個cable是不是我們講是不是idle

218
00:12:06,011 --> 00:12:09,035
如果是idle呢 我們就把他送上去

219
00:12:09,035 --> 00:12:14,025
那送上去之後呢 你要繼續聽有沒有發生collision嘛

220
00:12:14,025 --> 00:12:16,041
剛剛提到 因為我們有collision的機制

221
00:12:16,041 --> 00:12:19,065
我們會繼續聽有沒有發生collision

222
00:12:19,065 --> 00:12:23,011
我們的問題就是說 那你要聽多久？

223
00:12:23,011 --> 00:12:25,071
就是說我們把封包送上去之後呢

224
00:12:25,071 --> 00:12:28,051
你要繼續聽有沒有發生collision

225
00:12:28,051 --> 00:12:30,095
但是我們要聽多久

226
00:12:30,095 --> 00:12:36,021
才能確定這個封包有沒有發生collision

227
00:12:36,021 --> 00:12:37,091
我們到底要聽多久

228
00:12:37,091 --> 00:12:43,008
就可以知道這個封包不會發生collision

229
00:12:43,008 --> 00:12:45,088
這是所謂的collision window的意思就是說

230
00:12:45,088 --> 00:12:49,038
封包丟上去之後 到底要花多長的時間

231
00:12:49,038 --> 00:12:54,038
我們才能夠確認這個封包有沒有發生collision

232
00:12:54,038 --> 00:12:57,035
那我們說這個發生collision

233
00:12:57,035 --> 00:13:00,068
最快的就是這兩個工作站

234
00:13:00,068 --> 00:13:03,051
就同時送的這兩個 同時送的兩個工作站

235
00:13:03,051 --> 00:13:05,071
他們非常的靠近

236
00:13:05,071 --> 00:13:08,048
所以他們兩個一送上去馬上就撞在一起

237
00:13:08,048 --> 00:13:10,071
這是最快偵測

238
00:13:10,071 --> 00:13:13,071
那我們說那最晚偵測 就是你最

239
00:13:13,071 --> 00:13:17,071
要花最久的時間才能偵測collision的狀態

240
00:13:17,071 --> 00:13:21,065
就是說這兩個工作站是在網路的最遠的兩端

241
00:13:21,065 --> 00:13:24,055
最遠的兩端就是說 我一邊送上去

242
00:13:24,055 --> 00:13:28,011
然後他就慢慢慢慢 因為我們訊號要花時間嘛

243
00:13:28,011 --> 00:13:31,025
就跑到對方的門口 到了門口的時候

244
00:13:31,025 --> 00:13:34,038
還沒進門 然後這個station他就去聽

245
00:13:34,038 --> 00:13:37,001
發現也是idle 他也把他送上去了

246
00:13:37,001 --> 00:13:39,081
然後一送上去就撞在一起

247
00:13:39,081 --> 00:13:42,045
那撞在一起呢 這個訊號還要花一段時間

248
00:13:42,045 --> 00:13:45,025
慢慢地送回來到這邊

249
00:13:45,025 --> 00:13:50,021
所以我們說 在worst case 你把封包丟出去

250
00:13:50,021 --> 00:13:52,068
到你偵測有沒有發生collision

251
00:13:52,068 --> 00:13:56,045
你的訊號可能要從一端跑到另外一端

252
00:13:56,045 --> 00:13:59,021
然後跟另外最遠那一個撞在一起

253
00:13:59,021 --> 00:14:02,078
然後再跑回來 你才有辦法偵測到

254
00:14:02,078 --> 00:14:07,001
就是你要偵測的時間 至少要這樣的一個來回嘛

255
00:14:07,001 --> 00:14:10,035
這個來回 我們就叫round-trip time

256
00:14:10,035 --> 00:14:12,045
就是所謂的collision window

257
00:14:12,045 --> 00:14:18,035
所以collision window就是一個網段最遠的距離

258
00:14:18,035 --> 00:14:22,038
訊號來回的時間 我們後面會再介紹更詳細一點

259
00:14:22,038 --> 00:14:26,088
就是說我們 為了保證知道說

260
00:14:26,088 --> 00:14:31,088
我們剛剛送的這個封包 到底有沒有發生collision

261
00:14:31,088 --> 00:14:36,015
因為我們要繼續聽嘛 也就是說我們一定要聽多久的時間

262
00:14:36,015 --> 00:14:38,081
就是一定要聽這個來回的時間

263
00:14:38,081 --> 00:14:41,011
你才有辦法知道有沒有collision啊

264
00:14:41,011 --> 00:14:46,058
因為發生collision的最慢的狀況就是說

265
00:14:46,058 --> 00:14:50,091
跟你發生collision的對象他跟你在最遠的地方

266
00:14:50,091 --> 00:14:55,048
所以你一定要把訊號跑到最遠的地方然後再回來

267
00:14:55,048 --> 00:14:59,038
這樣你才能知道有沒有發生collision

268
00:14:59,038 --> 00:15:05,018
也就是說在這個時間之內 我們的封包不能送完

269
00:15:05,018 --> 00:15:07,055
因為我們還不知道有沒有發生collision

270
00:15:07,055 --> 00:15:09,041
我的封包不能送完

271
00:15:09,041 --> 00:15:13,038
那這個來回的時間我們講 在ethernet裡面

272
00:15:13,038 --> 00:15:18,085
就是51.2個microsecond 我們剛才有介紹說啊

273
00:15:18,085 --> 00:15:22,015
我們ethernet本身最長是多長？

274
00:15:22,015 --> 00:15:28,001
我們說一個網段是500公尺 我們可以接好幾個網段嘛

275
00:15:28,001 --> 00:15:30,058
那最多最多不管怎麼接

276
00:15:30,058 --> 00:15:37,018
來回最多是2.5公里 就是2500公尺

277
00:15:37,018 --> 00:15:42,038
好那我們說 2500公尺的這個距離 我們的訊號放上去

278
00:15:42,038 --> 00:15:48,038
電子 電子的速度在跑 跑了2500公尺 再回來

279
00:15:48,038 --> 00:15:52,075
這個時間要多久 這個時間就差不多是

280
00:15:52,075 --> 00:15:56,031
我們講是51.2µs

281
00:15:56,031 --> 00:16:00,011
差不多 來回51.2 µs

282
00:16:00,011 --> 00:16:07,078
那如果是51.2 µs 我們的網路的速度是10Mbps

283
00:16:07,078 --> 00:16:12,085
就是說我送的這個速度呢 是10Mbps

284
00:16:12,085 --> 00:16:15,068
就是說一秒鐘送10Mb

285
00:16:15,068 --> 00:16:20,021
可是我的來回的時間呢是51.2 µs

286
00:16:20,021 --> 00:16:24,088
就時間很短 可是我的速度呢是10Mb

287
00:16:24,088 --> 00:16:29,018
所以我用10Mbps乘上51.2 µs

288
00:16:29,018 --> 00:16:34,065
也就是說我在這個51.2 µs這個時間呢 我可以送多少量

289
00:16:34,065 --> 00:16:37,091
一個是時間 一個是你的速度

290
00:16:37,091 --> 00:16:41,038
所以一乘就發現 這個就是512bit

291
00:16:41,038 --> 00:16:51,005
就是說10Mbps乘上51.2 µs 他得到就是512個bits

292
00:16:51,005 --> 00:16:55,031
也就是說我們用10Mbps的速度送

293
00:16:55,031 --> 00:16:59,015
你一邊送你一邊要聽 那你至少要送多久

294
00:16:59,015 --> 00:17:02,098
至少要送到說 你的訊號跑到最遠的地方回來

295
00:17:02,098 --> 00:17:08,081
因為這個時間你才能偵測封包有沒有發生collision

296
00:17:08,081 --> 00:17:12,048
在這個之前 你不能把封包就送完了

297
00:17:12,048 --> 00:17:13,095
因為如果你把封包就送完了

298
00:17:13,095 --> 00:17:16,001
等下跑回來的時候collision

299
00:17:16,001 --> 00:17:18,065
我們就沒有辦法知道這個collision

300
00:17:18,065 --> 00:17:22,028
是你這個封包發生collision 還是因為你送完了嘛

301
00:17:22,028 --> 00:17:25,058
送完就過去啦 那後面如果發生collision是別人的封包

302
00:17:25,058 --> 00:17:26,055
跑回來collision

303
00:17:26,055 --> 00:17:29,098
所以你就不知道你的封包發生的collision

304
00:17:29,098 --> 00:17:32,081
是你這個封包還是是別人的封包

305
00:17:32,081 --> 00:17:35,061
也就是說我們封包丟出去

306
00:17:35,061 --> 00:17:40,041
我們要繼續聽那我們至少要聽51.2 µs

307
00:17:40,041 --> 00:17:47,015
那聽51.2 µs要 你會送多少的量 你會送512個bits

308
00:17:47,015 --> 00:17:51,095
那也就是說 他最多呢 最少512個bits

309
00:17:51,095 --> 00:17:54,035
就是我們所謂的64個bytes

310
00:17:54,035 --> 00:17:58,055
所以這個也是一個非常非常重要的這個ethernet裡面的參數

311
00:17:58,055 --> 00:18:01,058
就是說 我們剛剛有介紹過

312
00:18:01,058 --> 00:18:06,041
ethernet每一個封包最短要64個bytes

313
00:18:06,041 --> 00:18:10,041
這就是為什麼我們最短要64個bytes

314
00:18:10,041 --> 00:18:12,031
的一個最基本的這個道理

315
00:18:12,031 --> 00:18:14,051
就是說我們封包丟出去呢

316
00:18:14,051 --> 00:18:17,085
我要繼續聽有沒有發生collision

317
00:18:17,085 --> 00:18:22,051
那我要聽多久呢 我要聽一個來回的時間

318
00:18:22,051 --> 00:18:27,051
這個來回的時間是51.2 µs 那在這個時間

319
00:18:27,051 --> 00:18:33,098
我用10Mbps的速度去送 我至少要送512個bits

320
00:18:33,098 --> 00:18:39,025
所以我的封包的長度最少要512bits

321
00:18:39,025 --> 00:18:45,041
要不然你會在51.2 µs就把它送完 這是不對的

322
00:18:45,041 --> 00:18:47,081
所以變成說我們會設計成說

323
00:18:47,081 --> 00:18:49,085
每一個ethernet的封包

324
00:18:49,085 --> 00:18:51,025
我們就從這裡

325
00:18:51,025 --> 00:18:55,041
從destination開始 到最尾巴這樣子

326
00:18:55,041 --> 00:18:59,005
他至少要64個bytes

327
00:18:59,005 --> 00:19:03,075
64個bytes就是512個bits

328
00:19:03,075 --> 00:19:07,015
這個是相等的 所以這個道理是這樣

329
00:19:07,015 --> 00:19:09,015


