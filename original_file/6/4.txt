0:00:01.820,0:00:04.980
我們來看一下字串比對的技術

0:00:04.980,0:00:06.880
就是所謂的string matching algorihthms

0:00:07.060,0:00:09.400
在這個字串比對的演算法裡面

0:00:09.500,0:00:12.980
我們先來看看一般我們做封包內容比對

0:00:13.100,0:00:15.740
我們講這個比對引擎的結構

0:00:15.960,0:00:18.120
看一下這個圖我們知道說

0:00:18.360,0:00:22.460
封包是從網路這邊進來

0:00:22.460,0:00:23.920
就是網路的介面卡

0:00:23.920,0:00:24.920
所謂的網卡

0:00:25.020,0:00:27.020
我們網卡把封包收起來

0:00:27.020,0:00:29.000
一般叫作Packet Capture

0:00:29.000,0:00:30.940
就是抓到第一個封包

0:00:31.180,0:00:34.860
那我們會先做一個叫Decoder的動作

0:00:34.900,0:00:36.900
就是把封包上面的一個格式化

0:00:36.900,0:00:37.700
就是說

0:00:38.040,0:00:42.340
裡面可能有一些重複的特殊的字元先把它去掉

0:00:42.340,0:00:43.880
先把它解碼

0:00:44.080,0:00:47.260
然後我們最重要的是要把封包的內容拿出來

0:00:47.260,0:00:49.240
把封包內容拿出來之後

0:00:49.400,0:00:51.500
就會開始進行這個最關鍵的

0:00:51.500,0:00:53.500
叫做Pattern Matching Engine

0:00:53.700,0:00:56.100
這個引擎就是把封包的內容

0:00:56.220,0:00:59.400
把它從封包裡面萃取出來

0:00:59.640,0:01:04.420
然後跟我們剛剛提到的Patterm Data Base

0:01:04.600,0:01:06.600
就是特徵碼資料庫

0:01:06.600,0:01:07.980
它要做比對

0:01:07.980,0:01:09.500
在這個地方做比對

0:01:09.760,0:01:11.760
那比對這個動作就是由這個引擎

0:01:11.760,0:01:13.060
可能是軟體

0:01:13.280,0:01:15.720
也可能用硬體來協助加速

0:01:15.720,0:01:17.200
比對之後

0:01:17.660,0:01:19.660
可能有match

0:01:19.660,0:01:21.440
或者可能沒有match

0:01:21.680,0:01:25.720
我們就會把這個output結果通知剛剛提到的

0:01:25.720,0:01:27.600
可能通知我們的系統說

0:01:27.600,0:01:28.840
這個封包是乾淨的

0:01:28.980,0:01:31.080
這個封包是有問題的等等

0:01:31.200,0:01:34.060
就是封包進來先做封包的擷取

0:01:34.060,0:01:35.560
然後整理

0:01:35.720,0:01:37.720
然後把字串拿出來

0:01:37.860,0:01:39.720
再把那個content

0:01:39.720,0:01:41.040
封包的內容拿出來做比對

0:01:41.340,0:01:43.980
比對結果就輸出

0:01:43.980,0:01:45.800
每一個封包都要這樣做

0:01:45.900,0:01:49.960
所以這個處理的資料量是非常大

0:01:49.960,0:01:51.220
而且要常常做

0:01:51.220,0:01:52.860
每一個封包都要做這件事

0:01:53.020,0:01:55.020
我們就來看看

0:01:55.240,0:01:57.300
那到底什麼叫做字串比對呢

0:01:57.480,0:02:00.000
什麼叫做Patern Matching

0:02:00.000,0:02:01.100
或者String Matching

0:02:01.100,0:02:03.000
就是兩個字串到底一不一樣

0:02:03.000,0:02:04.300
這個非常有名

0:02:04.380,0:02:06.460
叫做字串比對的問題

0:02:06.620,0:02:11.440
我們就說一個string就是一個符號

0:02:11.440,0:02:13.340
就是一系列的符號

0:02:13.660,0:02:18.740
比如說一系列所謂的字元所形成的叫做一個string

0:02:18.740,0:02:20.200
那我們剛剛說

0:02:20.200,0:02:21.780
我們會有一個data base

0:02:22.040,0:02:26.180
就是會有一個特徵碼資料庫叫做P

0:02:26.180,0:02:27.240
它是一個set

0:02:27.680,0:02:29.680
它是一個a set of

0:02:29.860,0:02:31.860
finite set of strings

0:02:32.060,0:02:34.800
就是我每一個sting就是一個

0:02:34.960,0:02:38.560
等於說每一個特徵碼就是一個string

0:02:39.140,0:02:41.140
然後我有一個資料庫

0:02:41.140,0:02:41.960
我們叫做P

0:02:41.980,0:02:43.980
它有P1 P2到Pk

0:02:44.140,0:02:47.660
我有k個特徵碼的意思

0:02:47.660,0:02:49.660
假設我有k個特徵碼

0:02:49.660,0:02:51.560
這個也可以叫做Pattern

0:02:52.360,0:02:54.360
然後T是什麼

0:02:54.580,0:02:56.580
T就是把它想像成封包的內容

0:02:56.720,0:02:58.720
今天有一個封包進來

0:02:59.120,0:03:01.400
我們說把它的封包的頭尾去掉

0:03:01.400,0:03:03.220
把那個內容把它找出來

0:03:03.220,0:03:04.400
這個所謂的T

0:03:04.620,0:03:06.620
它也是一個Text String

0:03:06.860,0:03:09.640
因為封包的內容也是一些字元

0:03:09.640,0:03:10.760
就是字串

0:03:10.760,0:03:12.600
那問題是什麼

0:03:12.600,0:03:14.100
問題就是要問說

0:03:14.360,0:03:17.340
這個T裡面就是封包的內容

0:03:17.540,0:03:24.380
是不是含有這個特徵資料庫裡面的某一個特徵

0:03:24.380,0:03:25.820
或者某幾個特徵

0:03:25.820,0:03:27.660
那它們在哪裡

0:03:27.660,0:03:29.260
就這樣的意思

0:03:29.260,0:03:30.820
就是所謂的字串比對

0:03:30.820,0:03:32.400
就是要比對說

0:03:32.760,0:03:39.320
封包內容裡面是不是含有特徵資料庫裡面的某一個特徵

0:03:39.320,0:03:40.240
在哪裡

0:03:40.240,0:03:42.100
在哪個位置的意思

0:03:42.100,0:03:43.500
這就是所謂的問題

0:03:43.800,0:03:48.800
我們來看一個很直接的這種比對的演算法

0:03:49.020,0:03:52.460
就是說我們就看說這個就是我們封包的內容

0:03:53.340,0:03:56.600
就是我們把封包的內容已經萃取出來了

0:03:57.200,0:03:59.200
那這個是我們的特徵碼資料庫

0:03:59.200,0:04:01.640
就是我們這邊可能會有不同的特徵碼

0:04:01.640,0:04:03.600
我們講特徵碼的長度

0:04:03.600,0:04:04.880
可能有長有短

0:04:04.880,0:04:05.480
不一定

0:04:05.480,0:04:07.080
這就是我們的特徵碼

0:04:07.080,0:04:08.400
我們就是要問說

0:04:09.660,0:04:11.660
這個封包內容裡面

0:04:11.840,0:04:14.200
有沒有包含我們某一個特徵碼

0:04:14.380,0:04:17.200
我們就用某一個特徵碼來解釋

0:04:17.480,0:04:19.860
比如說我們用這個紫色的特徵碼

0:04:19.860,0:04:21.360
比如說這個特徵碼是這樣

0:04:21.820,0:04:24.840
等下這個紫色的特徵碼你要說

0:04:25.140,0:04:29.100
這個字串裡面有沒有含這個紫色的特徵碼

0:04:29.700,0:04:31.700
我們的做法可以很簡單

0:04:31.700,0:04:33.080
就是把特徵碼移過來

0:04:33.360,0:04:35.600
就是我們這邊把它對齊

0:04:35.780,0:04:39.260
看這個特徵碼的長度把它對齊

0:04:39.260,0:04:40.780
然後就開始比對

0:04:40.780,0:04:42.200
一個字一個字比

0:04:42.480,0:04:45.500
比如說A比A B C D

0:04:45.500,0:04:46.480
就一個一個比

0:04:46.560,0:04:48.640
完全一樣就叫做Match

0:04:49.040,0:04:51.040
一個不一樣就叫做不Match

0:04:51.040,0:04:52.900
因為沒有完全一樣就不算

0:04:52.900,0:04:53.860
也就是說

0:04:53.860,0:04:55.960
如果說這上面的這些內容

0:04:56.420,0:04:59.240
跟這上面的內容是一模一樣的

0:04:59.240,0:05:00.740
我們就說

0:05:00.740,0:05:01.980
這就是Match的意思

0:05:01.980,0:05:03.980
如果這個沒有Match

0:05:03.980,0:05:05.820
萬一沒有Match

0:05:06.100,0:05:08.400
我們就移一格

0:05:08.400,0:05:09.540
就是移一個byte

0:05:09.860,0:05:14.000
就看這裡沒有比對那這裡是不是可以比對

0:05:14.000,0:05:14.860
比這裡

0:05:14.860,0:05:16.640
那是比這裡

0:05:16.840,0:05:19.460
一樣再檢查一次

0:05:19.460,0:05:21.400
不管有沒有

0:05:21.400,0:05:22.240
繼續往前

0:05:22.240,0:05:23.600
就是一個一個一個這樣子

0:05:23.600,0:05:24.740
就是shift

0:05:24.740,0:05:25.480
我們叫做shift

0:05:25.760,0:05:27.940
往右位移這樣子

0:05:28.140,0:05:30.380
然後一直到最後面

0:05:30.380,0:05:31.680
最後面就是說

0:05:31.820,0:05:34.400
讓右邊對齊

0:05:34.560,0:05:36.560
然後左邊這樣子

0:05:36.560,0:05:38.280
看看這裡面的內容

0:05:38.460,0:05:41.880
和這裡面的內容是不是完全一樣

0:05:41.880,0:05:43.680
這是一個等於說

0:05:43.820,0:05:47.000
最直接最簡單的一個演算法

0:05:47.540,0:05:49.540
就是說從左邊對齊開始

0:05:49.540,0:05:50.360
開始比

0:05:50.360,0:05:52.040
不管有沒有

0:05:52.280,0:05:54.700
下一個就移一個移一個

0:05:55.100,0:05:59.540
移到最右邊對齊然後再比對

0:05:59.720,0:06:05.100
這個是一個很簡單的我們講字串比對的演算法

0:06:05.100,0:06:07.720
但這個演算法有一個最大的問題

0:06:07.720,0:06:09.120
就是它非常的慢

0:06:09.160,0:06:11.160
這邊要比一次

0:06:11.160,0:06:12.620
這個要比一次

0:06:12.620,0:06:14.480
然後這也要比一次

0:06:14.700,0:06:16.940
所以等於說這裡這裡有幾次

0:06:16.940,0:06:18.040
你就要比幾次

0:06:18.220,0:06:21.180
就等於說像這樣就是比一次

0:06:21.180,0:06:22.340
這樣又比一次

0:06:22.520,0:06:24.520
那每次比一次就要比什麼

0:06:24.680,0:06:26.900
就要比這個裡面有多少字

0:06:27.060,0:06:29.580
等於說要比這個長度

0:06:29.580,0:06:31.120
這個都要比

0:06:31.480,0:06:33.800
所以這個整個乘起來的話

0:06:33.800,0:06:35.380
可能就非常的慢

0:06:35.380,0:06:36.840
而且我們剛剛說

0:06:36.920,0:06:41.200
這個是比紫色這個字串而已

0:06:41.200,0:06:42.620
紫色這個特徵碼

0:06:42.620,0:06:43.980
那我的特徵碼

0:06:44.280,0:06:46.280
還有這麼多個

0:06:46.280,0:06:47.960
可能是幾千個

0:06:47.960,0:06:48.920
可能幾萬個

0:06:48.920,0:06:50.600
每一個都這麼比下去

0:06:50.760,0:06:52.760
然後每一個都要這樣比

0:06:53.240,0:06:56.860
這個時間我們講乘起來的話是非常非常可觀

0:06:56.860,0:06:58.160
而且非常的慢

0:06:58.800,0:07:02.300
所以這種演算法基本上是不能用的

0:07:02.520,0:07:04.520
是最直接最簡單

0:07:04.520,0:07:06.100
一般而言叫做暴力法

0:07:06.340,0:07:09.540
它把所有可能都把它走過一遍

0:07:09.540,0:07:11.480
可是是沒有效率的

0:07:11.480,0:07:12.580
這太慢了

0:07:12.580,0:07:13.640
我們說

0:07:13.840,0:07:17.060
所以字串比對演算法的挑戰在哪裡

0:07:17.060,0:07:18.200
就是說

0:07:18.200,0:07:19.500
因為我們做字串比對

0:07:19.620,0:07:24.820
我們要match每一個payload against all patterns

0:07:24.820,0:07:26.320
因為封包很多

0:07:26.440,0:07:28.440
每一個封包都要比對

0:07:28.440,0:07:29.620
每一個封包

0:07:29.940,0:07:33.060
那每一個封包要比對的pattern又這麼多

0:07:33.220,0:07:36.060
你看這個乘起來非常非常的可怕

0:07:36.060,0:07:37.500
而且我們說

0:07:37.500,0:07:39.140
這個pattern本身

0:07:39.300,0:07:42.760
就是特徵碼的長度不是固定的

0:07:42.880,0:07:44.880
它可能有的長有的短

0:07:45.200,0:07:47.920
比如說有一個Snort非常有名

0:07:48.260,0:07:50.800
這個Snort就是一格非常有名的IDS

0:07:50.800,0:07:52.660
它既然是IDS

0:07:52.820,0:07:55.740
所以它一定有它的特徵碼資料庫

0:07:56.120,0:07:58.120
在它的特徵碼資料庫裡面

0:07:58.120,0:07:59.580
那個特徵碼

0:07:59.580,0:08:00.820
我們說它的長度

0:08:00.820,0:08:02.280
因為不同的惡意程式

0:08:02.800,0:08:07.960
我們找到它的特徵的字串可能長度是不一樣

0:08:07.960,0:08:09.200
可能會不相同

0:08:09.680,0:08:13.320
它的特徵碼可以從一個byte到一百二十二個byte

0:08:13.320,0:08:14.260
都有

0:08:14.260,0:08:15.180
這個很特別

0:08:15.420,0:08:17.500
就是它那個特徵碼資料庫裡面有很多很多特徵碼

0:08:17.640,0:08:19.640
有的是一個byte

0:08:19.940,0:08:21.940
有的是一百二十二個byte

0:08:21.940,0:08:23.440
所以不一定

0:08:23.440,0:08:24.760
比如說這個

0:08:25.760,0:08:30.240
GET/script/root.exe一個問號

0:08:30.500,0:08:34.340
這個就是IDS裡面的一個特徵碼

0:08:34.340,0:08:36.000
它的長度去算

0:08:36.000,0:08:37.480
一二三四五六七八九

0:08:37.760,0:08:39.900
大概二三十個byte的意思

0:08:40.560,0:08:46.120
也就是說這個pattern可能會出現在payload裡面的任何一個地方

0:08:46.120,0:08:47.460
我們剛剛提到

0:08:47.700,0:08:50.900
可能會出現在這個pattern的最前面

0:08:50.900,0:08:52.640
或者中間或者最後面

0:08:52.880,0:08:54.880
所以你沒有把它全部比完

0:08:54.900,0:08:56.900
你就不知道是不是出現

0:08:56.960,0:09:02.380
就是它的位置可能是在封包內容裡面的任何一個地方

0:09:02.380,0:09:03.720
這個也是困難的地方

0:09:04.180,0:09:08.540
所以我們說總共的pattern通常也很多

0:09:09.160,0:09:11.160
在IDS裡面是數千個

0:09:11.640,0:09:17.000
它數千因為它是針對一些特定的惡意程式蒐集的

0:09:17.480,0:09:19.640
也就是說pattern的數量很多

0:09:19.940,0:09:21.940
然後pattern的長度不一

0:09:22.720,0:09:26.180
然後每一個封包進來都要跟這些pattern做比對

0:09:26.560,0:09:30.520
所以這個挑戰就是說它的速度的挑戰是非常大的

0:09:30.520,0:09:32.420
我們來看一下說

0:09:32.420,0:09:34.140
像在這個Snort

0:09:34.600,0:09:38.100
這個所謂的open source的這個IDS

0:09:38.260,0:09:41.880
它有四個最大的所謂的routine

0:09:41.880,0:09:43.740
就是它裡面有四個最大的程式

0:09:44.280,0:09:46.280
比如說做字串比對的

0:09:46.280,0:09:47.840
做封包分類的

0:09:48.000,0:09:50.440
這個也是封包分類裡面的一個routine

0:09:50.440,0:09:52.000
其他的matching

0:09:52.200,0:09:54.660
其中這個字串比對

0:09:55.180,0:09:57.900
要佔掉31%的運算

0:09:57.900,0:09:59.560
可以看得出來說

0:10:00.060,0:10:02.940
像Snort這樣開源的軟體

0:10:03.520,0:10:07.000
它裡面負擔最重的就是在做字串比對

0:10:07.000,0:10:08.680
佔掉31%的意思

0:10:08.680,0:10:10.400
所以我們說

0:10:10.840,0:10:13.200
這個pattern matching這個routine

0:10:13.500,0:10:18.120
是IDS裡面最耗資源

0:10:18.280,0:10:20.280
我們叫resorce-intensive的task

0:10:20.280,0:10:22.060
就它自己耗得最多

0:10:22.280,0:10:25.160
因為它要花掉31%在做這個字串比對的工作

0:10:25.620,0:10:30.280
我們需要非常有效率的pattern matching的work的意思

0:10:30.280,0:10:33.080
所以我們如果在字串比對上面沒有好的演算法

0:10:33.380,0:10:37.920
這個地方會拖累這個IDS的功能

0:10:37.920,0:10:39.860
因為它會變慢

0:10:40.120,0:10:42.120
我們知道說變慢也會出問題

0:10:42.120,0:10:44.000
不夠快也是問題

0:10:44.000,0:10:45.900
那我們再來看看說

0:10:46.080,0:10:51.060
現在會使用字串比對的軟體到底有哪一些

0:10:51.160,0:10:53.160
我們剛剛講的是叫做Snort

0:10:53.460,0:10:55.460
Snort是非常有名的IDS

0:10:55.700,0:11:01.280
那它把全部這種字串比對的工作全部加起來

0:11:01.520,0:11:04.880
大概有62%在做字串比對

0:11:05.340,0:11:07.880
另外還有一個很有名的叫ClamAV

0:11:07.880,0:11:09.860
ClamAV

0:11:10.120,0:11:13.580
AV就是防病毒

0:11:13.580,0:11:15.560
就是antivirus

0:11:15.560,0:11:16.920
就是防毒軟體

0:11:16.920,0:11:18.920
它也是一個open source開源程式

0:11:19.120,0:11:25.180
就是說這個ClamAV本身大概有90%是在做pattern matching

0:11:25.180,0:11:27.400
因為它做防毒

0:11:27.400,0:11:29.140
就是病毒

0:11:29.340,0:11:32.440
那病毒一樣我們都是用字串來代表某一個病毒

0:11:32.640,0:11:35.560
它在比對的時候也要佔掉非常大的比例

0:11:35.820,0:11:37.820
另外一個是防垃圾郵件的

0:11:38.040,0:11:38.780
叫做Spam

0:11:38.780,0:11:40.040
也就是說垃圾郵件本身

0:11:40.500,0:11:44.340
垃圾郵件裡面也是因為它的字太多廣告

0:11:44.560,0:11:46.560
太多連結

0:11:46.700,0:11:49.000
所以它也會做很大的字串比對

0:11:49.320,0:11:51.320
大概花掉75%

0:11:51.360,0:11:55.900
我們可以看到說幾個比較有名的防垃圾的

0:11:56.040,0:11:58.040
防病毒的

0:11:58.840,0:12:00.840
這個IDS入侵偵測系統

0:12:01.060,0:12:05.680
其實你看這個字串比對這個比例都非常的高

0:12:05.740,0:12:12.220
最後我們看一下這個字串比對他的時間代價是非常昂貴的

0:12:12.640,0:12:17.660
這個是Intel所提供的一個從layer 2到layer7

0:12:17.880,0:12:21.000
不同的功能他要花多少時間

0:12:21.100,0:12:23.100
我們來這麼看

0:12:23.260,0:12:25.920
縱軸是這個應用軟體的複雜度

0:12:25.980,0:12:30.460
就是你要處理越多內容就越複雜

0:12:31.100,0:12:38.520
橫軸是說一個封包大概你需要幾個指令把這個封包處理完

0:12:38.520,0:12:40.000
就是這個封包進來

0:12:40.200,0:12:41.820
我們講去頭去尾開始做檢查

0:12:41.820,0:12:43.620
最後把它送出去

0:12:43.900,0:12:47.920
封包從進到這個設備到從這個設備離開

0:12:48.740,0:12:52.900
中間要花多少指令來處理它的意思

0:12:53.140,0:12:55.880
我們說一般Switching是說

0:12:56.280,0:12:58.280
像Layer 2的交換器

0:12:58.440,0:12:59.580
交換器是最簡單

0:12:59.580,0:13:01.200
因為它只處理到我們叫做Layer 2

0:13:01.340,0:13:03.340
處理到Mac Layer

0:13:03.340,0:13:05.020
所以他大概是說

0:13:05.180,0:13:07.820
一個1500個byte的封包

0:13:08.000,0:13:10.000
這是封包的大小

0:13:10.260,0:13:14.000
一般ethernet就是1500個byte 就是一個封包的長度就是1500個byte

0:13:14.860,0:13:16.860
大概需要花50個指令

0:13:17.160,0:13:20.020
就一個封包進來大概花50個

0:13:20.220,0:13:22.960
比如說加減移檢查

0:13:23.080,0:13:27.380
大概是50個指令可以把一個封包處理完的意思

0:13:27.380,0:13:33.440
因為它比較簡單隨著網路設備的功能從最簡單的交換機

0:13:33.440,0:13:34.800
會到路由器Routing

0:13:34.960,0:13:37.740
它就會處理IP位置了

0:13:39.140,0:13:41.140
QoS就是服務品質

0:13:41.400,0:13:45.460
可能會處理到IP 加上TCP/ UDP 的port number

0:13:45.960,0:13:49.580
再往上 網路監控 附載平衡

0:13:50.400,0:13:53.300
還有我們看到的防火牆 VPN

0:13:53.300,0:13:57.560
這裡入侵偵測跟這個防毒

0:13:57.800,0:14:00.080
這個Virus Scan就是掃毒

0:14:00.380,0:14:02.780
這兩個工作是非常複雜的

0:14:02.780,0:14:04.340
我們看一下

0:14:04.380,0:14:06.660
到了最頂級的這個

0:14:06.820,0:14:10.180
我們所謂的入侵偵測跟這個病毒的掃毒

0:14:10.520,0:14:14.560
它要花多少的功夫來處理這個封包呢

0:14:14.840,0:14:19.920
我們說這個是一個byte就要30個指令

0:14:20.240,0:14:24.780
因為它要做剛剛提到的比對他要做很多這種比對的動作

0:14:25.140,0:14:27.140
所以相對的負擔就大很多

0:14:27.380,0:14:31.700
一個byte就要30個指令才能比對完成

0:14:31.960,0:14:37.200
一樣 所以一個1500byte的封包

0:14:37.540,0:14:40.180
就是一個大封包 這個乘起來就是30乘上1000

0:14:40.760,0:14:46.220
大概要45K的指令 這只有50的指令

0:14:46.220,0:14:47.380
這是45K的指令

0:14:48.480,0:14:51.080
所以你可以看到說 一個封包進來

0:14:51.480,0:14:53.480
從最簡單的Layer2得交換機

0:14:53.480,0:14:55.140
就很快就出去了

0:14:55.200,0:14:58.040
因為它處理這個封包的指令非常得少

0:14:58.220,0:15:04.580
到我們要做入侵偵測   到這個病毒掃描的話 一個封包進來要花掉45K

0:15:05.060,0:15:09.620
就四萬五千個指令才能把它處理完

0:15:10.160,0:15:18.360
所以相對於說 在做字串比對來講 我們說它的時間的代價是非常的昂貴的

0:15:18.620,0:15:23.340
這也特別顯示說 字串比對的技術是非常非常的關鍵