1
00:00:09,008 --> 00:00:10,031
好 我們剛剛提到說

2
00:00:10,031 --> 00:00:12,021
這個所謂的collision window

3
00:00:12,021 --> 00:00:15,065
就強調於在於說我們要花多久的時間

4
00:00:15,065 --> 00:00:19,055
才可以確認說我們所送出去的封包

5
00:00:19,055 --> 00:00:21,098
到底有沒有發生collision

6
00:00:21,098 --> 00:00:23,095
我們這個叫做所謂的collision window

7
00:00:23,095 --> 00:00:25,035
那這個collision window

8
00:00:25,035 --> 00:00:30,021
他的這個在 10M ethernet的這個標準之下呢

9
00:00:30,021 --> 00:00:34,008
我們說 他就是來回的一個round-trip time

10
00:00:34,091 --> 00:00:38,011
collision window就相當於一個round-trip delay

11
00:00:38,011 --> 00:00:41,025
就是我們假設這個網路呢 最遠的兩端

12
00:00:41,025 --> 00:00:45,078
我們訊號傳遞的時間假設一邊一趟叫做A

13
00:00:45,078 --> 00:00:50,028
那我們講來回就是所謂的2A 那這個2A的時間

14
00:00:50,028 --> 00:00:54,001
就是我們要偵測有沒有發生collision的時間

15
00:00:54,001 --> 00:00:57,038
事實上 如果這個發生衝撞的兩個station

16
00:00:57,038 --> 00:01:00,018
他們越靠近的話 這個時間就越短

17
00:01:00,018 --> 00:01:04,011
因為我只要送出去 他可能在旁邊 他立刻送出來

18
00:01:04,011 --> 00:01:06,028
這兩個幾乎同時間送出去

19
00:01:06,028 --> 00:01:08,085
這個我偵測很快 因為他們很靠近

20
00:01:08,085 --> 00:01:11,011
訊號送過去很快就衝撞

21
00:01:11,011 --> 00:01:13,005
很快就回來 因為距離很短

22
00:01:13,005 --> 00:01:18,028
但是如果我們說 如果這兩個會衝撞的collision

23
00:01:18,028 --> 00:01:21,065
會衝撞這個station他們的距離比較遠的話

24
00:01:21,065 --> 00:01:24,091
那我們的訊號就要送的比較久才會到對方

25
00:01:24,091 --> 00:01:27,035
然後發生collision再回來

26
00:01:27,035 --> 00:01:30,025
這個來回的時間就會花比較長的時間

27
00:01:30,025 --> 00:01:34,058
好 那底下呢我們就用一個例子來解釋說

28
00:01:34,058 --> 00:01:36,058
這個發生collision

29
00:01:36,058 --> 00:01:40,068
在最長的這個時間狀況之下要花多久的時間

30
00:01:40,068 --> 00:01:43,098
我們看一下 我們首先說假設

31
00:01:43,098 --> 00:01:49,071
像在這個例子上面呢 我們有兩個工作站

32
00:01:49,071 --> 00:01:53,068
一個A在最左邊 B在最右邊

33
00:01:53,068 --> 00:01:56,021
那我們假設呢這個cable的這個

34
00:01:56,021 --> 00:01:58,051
我們叫做propagation delay 就是a

35
00:01:58,051 --> 00:02:00,085
就是他們最遠的這個距離呢

36
00:02:00,085 --> 00:02:04,041
就是需要花這個a的這個時間

37
00:02:04,041 --> 00:02:07,045
傳遞時間 從一邊到一邊 是a的時間

38
00:02:07,045 --> 00:02:12,021
那我們說在時間t 在time t的時候呢

39
00:02:12,021 --> 00:02:15,091
A就開始把封包丟上去

40
00:02:15,091 --> 00:02:21,005
A丟上去 好然後這個丟上去之後就開始往兩邊跑嘛

41
00:02:21,005 --> 00:02:26,045
那因為我們講 A在最邊邊嘛 所以他再往邊邊跑的呢

42
00:02:26,045 --> 00:02:29,055
當然就會被我們叫做所謂的terminator

43
00:02:29,055 --> 00:02:32,058
最邊邊就把它吸掉 把它吸收掉了啦

44
00:02:32,058 --> 00:02:36,048
但是呢 他的封包呢就會開始往右邊跑

45
00:02:36,048 --> 00:02:40,051
我們說 這個跑到最右邊

46
00:02:40,051 --> 00:02:43,045
這B 在B的這個門口

47
00:02:43,045 --> 00:02:49,008
我們這個時候叫t+a-ℇ 就是t是傳送的時間

48
00:02:49,008 --> 00:02:53,031
然後他花a的時間 這個訊號花a的時間

49
00:02:53,031 --> 00:02:56,071
然後到的最遠的另外一端 就是B

50
00:02:56,071 --> 00:02:59,001
那我們說-ℇ 就代表是說

51
00:02:59,001 --> 00:03:04,028
在這個到達B的門口之前的一個短短的時間

52
00:03:04,028 --> 00:03:08,085
代表說還沒有到達B啦 因為如果到了B  B要送

53
00:03:08,085 --> 00:03:11,058
她一聽是busy B就不能送了

54
00:03:11,058 --> 00:03:13,048
因為我們的protocol就是說

55
00:03:13,048 --> 00:03:16,055
在送之前會去聽聽看 只要是busy

56
00:03:16,055 --> 00:03:18,075
就看到訊號他就自己就不能送

57
00:03:18,075 --> 00:03:21,051
那我們現在為了要讓這個B可以送

58
00:03:21,051 --> 00:03:26,061
所以我們說這個訊號呢 只在t+a-ℇ

59
00:03:26,061 --> 00:03:30,071
然後到達這個B的門口 這個時候B就去聽聽看

60
00:03:30,071 --> 00:03:33,055
就發現說這個時候去聽的話

61
00:03:33,055 --> 00:03:36,051
當然他就是按照我們的設計

62
00:03:36,051 --> 00:03:39,078
現在去聽這個地方 他是idle的

63
00:03:39,078 --> 00:03:42,018
idle的結果呢 我們就是說好

64
00:03:42,018 --> 00:03:44,071
那idle的話呢 B就把它送上去

65
00:03:44,071 --> 00:03:48,031
就這個黃色的這個 B就把封包丟上去啦

66
00:03:48,031 --> 00:03:52,045
因為他發現他去偵測這個cable上面是idle

67
00:03:52,045 --> 00:03:57,008
那接下來就是說 這兩個呢就會撞在一起

68
00:03:57,008 --> 00:04:02,078
就是A的紫色的封包 跟這個B黃色的封包呢

69
00:04:02,078 --> 00:04:05,018
這兩個封包呢就會撞在一起

70
00:04:05,018 --> 00:04:07,098
那撞在一起的封包呢 就會開始一樣

71
00:04:07,098 --> 00:04:11,035
會擴散開來 那擴散到最右邊

72
00:04:11,035 --> 00:04:13,011
一樣他有terminator

73
00:04:13,011 --> 00:04:16,058
會把這個反正terminator就是反正所有的訊號

74
00:04:16,058 --> 00:04:19,031
到了terminator就會把它吸掉

75
00:04:19,031 --> 00:04:22,061
就沒有了沒關係 但是呢最重要的是說

76
00:04:22,061 --> 00:04:25,001
他會往另外一邊彈回去啊

77
00:04:25,001 --> 00:04:28,028
所以我們發現到這個collision的封包呢

78
00:04:28,028 --> 00:04:30,065
就會再送回給A

79
00:04:30,065 --> 00:04:35,041
所以這裡最關鍵的地方就是說 那我們看一下A

80
00:04:35,041 --> 00:04:41,098
他在t的時間開始送 在t+a的時候就快到達B的門口

81
00:04:41,098 --> 00:04:45,051
然後B這個時候送上去就collision

82
00:04:45,051 --> 00:04:51,035
然後還要再花a的時間 這個訊號傳回給A嘛

83
00:04:51,035 --> 00:04:57,025
所以最後呢在t+2a-ℇ的時候呢

84
00:04:57,025 --> 00:05:01,068
這個訊號會回到A的這個門口來

85
00:05:01,068 --> 00:05:04,081
那當然如果是t+2a就到了

86
00:05:04,081 --> 00:05:09,075
這個時候A就發現了collision 就是說你看對A來講

87
00:05:09,075 --> 00:05:13,001
事實上他是把這個封包丟出去

88
00:05:13,001 --> 00:05:15,061
然後在這個地方發生collision

89
00:05:15,061 --> 00:05:18,055
collision之後呢再送回來

90
00:05:18,055 --> 00:05:23,061
那他要這麼久的時間才知道有沒有發生collision

91
00:05:23,061 --> 00:05:27,068
也就是這個collision本身事實上 從A的角度來看

92
00:05:27,068 --> 00:05:32,031
他把封包送上去 他事實上必須經過2a的時間

93
00:05:32,031 --> 00:05:36,005
他才知道有沒有發生collision

94
00:05:36,005 --> 00:05:38,061
所以這個時間點就是說 這是跑不掉的

95
00:05:38,061 --> 00:05:43,001
因為網路的距離的關係 他一定要花2a

96
00:05:43,001 --> 00:05:45,058
2a就是訊號來回的時間

97
00:05:45,058 --> 00:05:50,015
這個是想避免 想減少 也不能減少

98
00:05:50,015 --> 00:05:54,091
因為訊號他就是一定要送給對方 然後再跑回來

99
00:05:54,091 --> 00:05:57,035
這個2a的時間是跑不掉的

100
00:05:57,035 --> 00:06:01,091
那在這個也就是說 最糟糕的情況之下

101
00:06:01,091 --> 00:06:07,068
我A送出去的封包 他要花2a的時間才會再回來

102
00:06:07,068 --> 00:06:09,075
那在這個時間之內

103
00:06:09,075 --> 00:06:12,091
我們就不可以封包送完了

104
00:06:12,091 --> 00:06:17,085
因為我要花2a的時間才能判斷封包到底有沒有collision

105
00:06:17,085 --> 00:06:21,075
那在這個還沒有確認collision之前

106
00:06:21,075 --> 00:06:25,088
我的封包不能送完

107
00:06:25,088 --> 00:06:27,071
那我們來舉一個例子說

108
00:06:27,071 --> 00:06:31,051
那如果我們把封包送完了怎麼辦

109
00:06:31,051 --> 00:06:35,068
如果說A的封包太短 我們講太短

110
00:06:35,068 --> 00:06:40,065
那假設他的封包長度只有a 我們用時間來看只有a

111
00:06:40,065 --> 00:06:42,081
那他會發生什麼事情 也就是說

112
00:06:42,081 --> 00:06:45,045
a的時候相當於在這個時間點

113
00:06:45,045 --> 00:06:50,031
我們講說 好 在t+a的時候呢我們說

114
00:06:50,031 --> 00:06:54,025
因為A的封包比較短嘛 他在t+a他已經送完了

115
00:06:54,025 --> 00:06:58,051
那送完了之後他這個封包這邊就已經 尾巴結束了嘛

116
00:06:58,051 --> 00:07:01,061
一開始在這邊送 到了t+a的時候呢

117
00:07:01,061 --> 00:07:03,041
他封包已經送完了

118
00:07:03,041 --> 00:07:05,055
所以送完了之後對A來講

119
00:07:05,055 --> 00:07:09,038
他已經送完啦 可是送完之後發現

120
00:07:09,038 --> 00:07:13,005
送完之後在t+2a 已經送完了喔

121
00:07:13,005 --> 00:07:16,048
送完之後經過A的時候才發現collision跑回來了

122
00:07:16,048 --> 00:07:21,078
這個時候A他就會所謂的confuse啦 他就會不知道說

123
00:07:21,078 --> 00:07:26,015
那我現在我的封包在t+a就已經送完了

124
00:07:26,015 --> 00:07:30,058
可是我在t+2a的時候我偵測到一個collision

125
00:07:30,058 --> 00:07:34,091
這個collision是我當時送那個封包的collision嗎？

126
00:07:34,091 --> 00:07:38,051
不一定喔 就不一定囉 就有可能說

127
00:07:38,051 --> 00:07:42,045
譬如說我送完之後像這個封包 我可能送完了

128
00:07:42,045 --> 00:07:47,038
我這個cable就乾淨了 因為封包訊號就流過去了嘛

129
00:07:47,038 --> 00:07:50,088
那說不定在他的旁邊的兩個工作站

130
00:07:50,088 --> 00:07:53,035
在這個封包流過去之後呢

131
00:07:53,035 --> 00:07:57,095
他們都發現這個封包 這個cable已經變成idle了嘛

132
00:07:57,095 --> 00:07:59,075
那他們這兩個都把他送上去

133
00:07:59,075 --> 00:08:02,015
就collision 然後再送回來

134
00:08:02,015 --> 00:08:06,038
也就是說如果我們在t+a把封包送完

135
00:08:06,038 --> 00:08:10,091
那我發現在t+2a的時候呢發生的collision的訊號回來

136
00:08:10,091 --> 00:08:13,098
其實我不知道這個collision

137
00:08:13,098 --> 00:08:16,031
是不是我之前的封包的collision

138
00:08:16,031 --> 00:08:18,078
還是說我封包已經送完了

139
00:08:18,078 --> 00:08:23,015
然後是別人的collision跑回來送到我門口來

140
00:08:23,015 --> 00:08:26,075
所以我就不知道那個封包有沒有發生collision

141
00:08:26,075 --> 00:08:30,011
那如果你的封包發生collision你會重送

142
00:08:30,011 --> 00:08:33,088
你的封包如果沒有發生collision你就不會重送啊

143
00:08:33,088 --> 00:08:35,045
這個關係很大的喔

144
00:08:35,045 --> 00:08:42,098
所以我們說為了確認每一個station在送封包的時候

145
00:08:42,098 --> 00:08:46,038
他都要有足夠的時間能夠判斷

146
00:08:46,038 --> 00:08:48,085
這個封包有沒有發生collision

147
00:08:48,085 --> 00:08:52,071
那因為偵測collision我們說

148
00:08:52,071 --> 00:08:55,068
他最多他需要2a的時間

149
00:08:55,068 --> 00:08:58,078
這是等於說為了保證

150
00:08:58,078 --> 00:09:03,008
有沒有辦法偵測到有沒有collision 保證一定要2a啦

151
00:09:03,008 --> 00:09:08,085
就是2a在我們這個標準理面呢 剛好就是51.2 µs

152
00:09:08,085 --> 00:09:10,088
我們就來看看就是說

153
00:09:10,088 --> 00:09:16,015
為了確認你的封包在傳送的時候呢有沒有發生collision

154
00:09:16,015 --> 00:09:20,065
所以你一定要聽collision window的時間

155
00:09:20,065 --> 00:09:23,088
而這個時間就是來回的時間

156
00:09:23,088 --> 00:09:28,078
阿這個時間在標準裡面 就是51.2 µs

157
00:09:28,078 --> 00:09:32,065
然後加上你送的速度 是10Mbps

158
00:09:32,065 --> 00:09:37,035
所以這個一乘起來 就是你至少要送512bits

159
00:09:37,035 --> 00:09:40,025
也就是說換算成byte就是64bytes

160
00:09:40,025 --> 00:09:42,028
就是你的封包呢不能太短

161
00:09:42,028 --> 00:09:43,091
因為如果你的封包太短

162
00:09:43,091 --> 00:09:47,025
我們剛剛提到 你可能其實你已經封包送完了

163
00:09:47,025 --> 00:09:50,008
可是你後面呢竟然又聽到一個collision

164
00:09:50,008 --> 00:09:52,078
你就不知道這個collision是不是你的封包發生collision

165
00:09:52,078 --> 00:09:55,068
還是別人的封包發生collision

166
00:09:55,068 --> 00:09:58,075
所以這個例子裡面 我們剛提到

167
00:09:58,075 --> 00:10:03,078
我們在t的時候呢 A開始送 然後在

168
00:10:03,078 --> 00:10:07,011
我們假設a 代表說一個link的latency

169
00:10:07,011 --> 00:10:10,001
就是一個link一段 他們的propagation delay

170
00:10:10,001 --> 00:10:12,068
他的時間這個要花多少時間把訊號

171
00:10:12,068 --> 00:10:15,088
從一端送到另外一端 我們叫a

172
00:10:15,088 --> 00:10:20,091
我們剛剛提到說 A在t的時間開始送

173
00:10:20,091 --> 00:10:24,075
然後在t+a的時間會到這個B的門口

174
00:10:24,075 --> 00:10:27,001
那假設呢我們說

175
00:10:27,001 --> 00:10:29,071
這個B呢這個時候開始把封包丟出去

176
00:10:29,071 --> 00:10:33,018
然後這個就會馬上collision 馬上collision之後呢

177
00:10:33,018 --> 00:10:35,065
B就偵測到了 那B偵測到

178
00:10:35,065 --> 00:10:40,021
按照我們剛剛講的 他就會送一個jam 32-bit

179
00:10:40,021 --> 00:10:41,061
讓他撞得更嚴重一點

180
00:10:41,061 --> 00:10:45,065
阿這個地方反正這個collision已經發生了嘛

181
00:10:45,065 --> 00:10:49,045
所以B可能就會再送一個32-bit讓他撞得更嚴重

182
00:10:49,045 --> 00:10:51,045
好 那同時呢

183
00:10:51,045 --> 00:10:55,091
這個衝撞的這個封包呢 就會再送回給A

184
00:10:55,091 --> 00:10:58,085
但是A沒有辦法發現這個事情

185
00:10:58,085 --> 00:11:00,065
沒有辦法發現這個事實

186
00:11:00,065 --> 00:11:05,008
一直要等到t+2a 就是這個衝撞的這個訊號呢

187
00:11:05,008 --> 00:11:08,075
也要花另外a的時間 才有辦法回到

188
00:11:08,075 --> 00:11:11,041
這個所謂的station A這邊來嘛

189
00:11:11,041 --> 00:11:13,078
所以在t+2a的時間點

190
00:11:13,078 --> 00:11:17,075
這個station A呢才有辦法偵測到

191
00:11:17,075 --> 00:11:20,001
那我們最後的結論就是說

192
00:11:20,001 --> 00:11:24,028
A呢他就必須一直送這個封包

193
00:11:24,028 --> 00:11:27,041
因為他為了偵測這個collision所以他必須一直送

194
00:11:27,041 --> 00:11:31,028
我們說A must transmit for 2a

195
00:11:31,028 --> 00:11:38,011
就是A這個工作站呢 他一定要送2a的時間 他要持續的送

196
00:11:38,011 --> 00:11:41,061
因為他要花2a的時間才有辦法偵測有沒有collision

197
00:11:41,061 --> 00:11:45,071
所以那必須至少送2a的時間 這麼久

198
00:11:45,071 --> 00:11:49,048
那送2a的時間可以送多少量

199
00:11:49,048 --> 00:11:51,085
我們說網路的長度呢

200
00:11:51,085 --> 00:11:56,071
如果是標準的所謂的2500公尺的長度

201
00:11:56,071 --> 00:12:01,008
那訊號來回的時間 大概是51.2 µs

202
00:12:01,008 --> 00:12:05,001
這是可以算得出來的 就是說事實上

203
00:12:05,001 --> 00:12:08,081
我們說200公尺遠的距離 中間可能還有repeater

204
00:12:08,081 --> 00:12:11,015
還有我們講transmitter

205
00:12:11,015 --> 00:12:14,078
還有這個我們之前介紹的像所謂的tape

206
00:12:14,078 --> 00:12:20,025
所以我們的封包從這個工作站丟進去 經過這個cable

207
00:12:20,025 --> 00:12:25,045
經過這個repeater 反正中間有一些設備都沒有關係

208
00:12:25,045 --> 00:12:27,031
訊號的轉送都算進去

209
00:12:27,031 --> 00:12:32,001
就是來回時間大概就是51.2 µs

210
00:12:32,001 --> 00:12:37,028
那我們說2a的時間就是51.2 µs

211
00:12:37,028 --> 00:12:40,061
那我們至少要送這麼長的時間

212
00:12:40,061 --> 00:12:44,025
那送這麼長的時間到底你會送多少量

213
00:12:44,025 --> 00:12:47,085
這跟什麼有關係呢？跟你的網路速度就有關了

214
00:12:47,085 --> 00:12:49,071
網路速度有關

215
00:12:49,071 --> 00:12:53,048
就是說如果我們的網路速度呢是10Mbps

216
00:12:53,048 --> 00:12:56,091
我們送了 我們必須送2a的時間

217
00:12:56,091 --> 00:13:01,061
那這個時間就是算起來 就是512bits

218
00:13:01,061 --> 00:13:04,075
就是說我們至少要送64個

219
00:13:04,075 --> 00:13:10,028
這個相當於就是等於就是64個bytes的意思

220
00:13:10,028 --> 00:13:14,018
這個我們講這就是64個bytes的由來

221
00:13:14,018 --> 00:13:15,088
就是說為什麼

222
00:13:15,088 --> 00:13:21,031
ethernet的封包最短一定要是64個bytes

223
00:13:21,031 --> 00:13:23,038
就是因為說我們考慮到說

224
00:13:23,038 --> 00:13:25,071
我們要做所謂的collision的偵測

225
00:13:25,071 --> 00:13:29,015
那collision的偵測呢一定要偵測2a的時間

226
00:13:29,015 --> 00:13:35,015
那在標準裡面 這個2a的時間來回就是51.2 µs

227
00:13:35,015 --> 00:13:37,075
那你至少要送這麼久

228
00:13:37,075 --> 00:13:42,051
那我們的速度呢又是10Mb 所以這個一乘起來

229
00:13:42,051 --> 00:13:45,078
就是說那你至少要送512bits

230
00:13:45,078 --> 00:13:48,015
至少你要送64個bytes

231
00:13:48,015 --> 00:13:50,005
這是為什麼我們講說 ethernet呢

232
00:13:50,005 --> 00:13:53,031
最短最短就是所謂64個bytes啦

233
00:13:53,031 --> 00:13:56,001
那我們當然也可以從另外一個角度來看

234
00:13:56,001 --> 00:14:00,091
就是我們為了要限制這個網路的這個latency

235
00:14:00,091 --> 00:14:02,068
就網路最長的latency呢

236
00:14:02,068 --> 00:14:07,025
我們講把他設定成51.2 假設用這樣來設計的話

237
00:14:07,025 --> 00:14:09,088
那倒過來講 就我們假設呢

238
00:14:09,088 --> 00:14:15,061
我們不希望這個網路的latency呢太長 或者太久

239
00:14:15,061 --> 00:14:17,025
所以我們先設計說

240
00:14:17,025 --> 00:14:21,075
假設我希望是51.2 µs 那用這個去倒推

241
00:14:21,075 --> 00:14:29,091
也可以推到說 那你網路呢最長就是2.5公里

242
00:14:29,091 --> 00:14:32,078
大概這個長度就是指這樣的意思

243
00:14:32,078 --> 00:14:36,065
所以不管是從先有網路的長度

244
00:14:36,065 --> 00:14:40,008
2.5公里倒推我們的這個

245
00:14:40,008 --> 00:14:44,028
所謂的round-trip time是51.2 µs

246
00:14:44,028 --> 00:14:46,028
或者說我們先設定

247
00:14:46,028 --> 00:14:50,081
我們這個來回的時間不超過51.2 µs

248
00:14:50,081 --> 00:14:55,065
我倒推網路最多呢 就是2.5公里 都可以啦

249
00:14:55,065 --> 00:14:57,051
就是說我們在標準裡面

250
00:14:57,051 --> 00:15:01,038
就是我的網路呢 最長是2.5公里

251
00:15:01,038 --> 00:15:07,065
那訊號來回 是51.2 µs 然後如果用10Mbps來送

252
00:15:07,065 --> 00:15:12,095
那得到的就是512bits 就是64bytes

253
00:15:12,095 --> 00:15:16,071
我們講這個是在ethernet裡面非常重要的一個參數

254
00:15:16,071 --> 00:15:22,021
目前有兩個很重要 一個就是封包最長1518個byte

255
00:15:22,021 --> 00:15:26,025
這是為了大家公平的使用這個cable

256
00:15:26,025 --> 00:15:31,011
不要送太長 而且送太長可能會獨佔就佔得太久

257
00:15:31,011 --> 00:15:34,058
另外一個不能送太短 就64個bytes

258
00:15:34,058 --> 00:15:37,048
那不能送太短的理由是因為

259
00:15:37,048 --> 00:15:42,021
我們要成功的偵測你送的封包有沒有發生collision

260
00:15:42,021 --> 00:15:45,051
如果你的封包送的太短就沒有辦法

261
00:15:45,051 --> 00:15:49,011
有可能沒有辦法正確偵測的這個封包是不是

262
00:15:49,011 --> 00:15:51,021
有沒有發生collision

