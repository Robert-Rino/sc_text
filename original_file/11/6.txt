2
00:00:00,000 --> 00:00:02,780
那接下來我們來看一下

3
00:00:02,780 --> 00:00:06,610
第二個技術所謂的Application Level Firewall

4
00:00:06,610 --> 00:00:08,810
一般叫做Application proxy

5
00:00:08,810 --> 00:00:13,610
我們說他提供幾乎是最安全的這種所謂的資料的保護

6
00:00:13,610 --> 00:00:18,410
為什麼呢 因為他會檢查每一個layer

7
00:00:18,410 --> 00:00:21,680
所有通訊的內容他都會檢查

8
00:00:21,680 --> 00:00:24,350
包含說所有的application data

9
00:00:24,350 --> 00:00:26,910
就是封包的內容他都可以檢查

10
00:00:26,910 --> 00:00:30,280
因為他會 等於說他是一個proxy

11
00:00:30,280 --> 00:00:31,880
他會把兩邊建連線

12
00:00:31,880 --> 00:00:35,680
所有連線的資料就到這個proxy

13
00:00:35,680 --> 00:00:39,150
這proxy會另外再建連線到後端的真正的server

14
00:00:39,150 --> 00:00:41,310
他介於兩者之間

15
00:00:41,310 --> 00:00:46,110
我們說 從一個client到一個server的連線

16
00:00:46,110 --> 00:00:49,380
我們說 intercepted by the proxy

17
00:00:49,380 --> 00:00:52,950
也就是說這個連線會被這個proxy所攔截

18
00:00:52,950 --> 00:00:55,950
可是呢 不是真的攔截 事實上它

19
00:00:55,950 --> 00:00:59,049
本來client要跟server建連線

20
00:00:59,049 --> 00:01:02,950
事實上等於說這個連線是先建到這個proxy

21
00:01:02,950 --> 00:01:05,550
然後由proxy再到這個server

22
00:01:05,550 --> 00:01:08,380
所以他等於是介於client跟server之間

23
00:01:08,380 --> 00:01:11,010
所有的連線都經過他的意思

24
00:01:11,010 --> 00:01:12,810
我們來看一下 首先呢

25
00:01:12,810 --> 00:01:17,450
這個封包的檢查是在application layer來檢查

26
00:01:17,450 --> 00:01:21,110
不像我們剛剛提到的第一種packet filter的技術

27
00:01:21,110 --> 00:01:24,880
封包的檢查是在network layer

28
00:01:24,880 --> 00:01:27,610
因為他只看那個IP或者是

29
00:01:27,610 --> 00:01:31,410
頂多就到這個所謂的TCP的header

30
00:01:31,410 --> 00:01:33,410
但是這個application proxy

31
00:01:33,410 --> 00:01:35,610
或者簡稱application gateway

32
00:01:35,610 --> 00:01:40,880
他是在application layer來檢查 也就是說

33
00:01:40,880 --> 00:01:46,580
封包送到這個網路是到application layer來

34
00:01:46,580 --> 00:01:49,510
檢查完之後呢再往下送到

35
00:01:49,510 --> 00:01:53,049
所謂的我們講如果是client到server的話

36
00:01:53,049 --> 00:01:56,849
等於說他是要經過這個application layer的檢查

37
00:01:56,849 --> 00:01:58,380
這是比較不一樣的地方

38
00:01:58,380 --> 00:02:03,450
然後這個他就可以看這個封包的內容

39
00:02:03,450 --> 00:02:06,580
所以他的這個檢查的這個精準度就更高

40
00:02:06,580 --> 00:02:13,009
譬如說我們可以避免說SNMP set command

41
00:02:13,009 --> 00:02:15,050
也就是說我們如果的策略裡面是說

42
00:02:15,050 --> 00:02:20,050
因為我這裡面的設備假設有用網管

43
00:02:20,050 --> 00:02:22,250
SNMP protocol來管理

44
00:02:22,250 --> 00:02:25,410
但是 如果你要做set 做設定

45
00:02:25,410 --> 00:02:27,180
我們說這個是不可以的

46
00:02:27,180 --> 00:02:29,550
這是我們管理的一個策略

47
00:02:29,550 --> 00:02:33,880
就是我們網路的設備是可以用SNMP來管理

48
00:02:33,880 --> 00:02:37,080
但是不可以被人家設定的意思

49
00:02:37,080 --> 00:02:41,910
那如果我們用剛剛提到的packet filter你就做不到

50
00:02:41,910 --> 00:02:43,580
因為我們只看header

51
00:02:43,580 --> 00:02:47,610
但如果說像這個所謂的application的proxy我就做的到

52
00:02:47,610 --> 00:02:50,610
因為他知道你現在你的封包是SNMP

53
00:02:50,610 --> 00:02:52,650
然後他會看封包的內容

54
00:02:52,650 --> 00:02:56,080
發現有一個set這個指令 然後就把它濾掉

55
00:02:56,080 --> 00:03:00,080
也就是說他會從application level這邊來做檢查

56
00:03:00,080 --> 00:03:04,610
我們就來看一下說 他的做法是怎麼樣

57
00:03:04,610 --> 00:03:07,650
也就是說如果這個proxy說

58
00:03:07,650 --> 00:03:09,979
這個連線是可以被允許的

59
00:03:09,979 --> 00:03:13,849
因為有時候連線是不被允許的就直接就擋掉了

60
00:03:13,849 --> 00:03:15,750
假設這個連線

61
00:03:15,750 --> 00:03:19,880
我們講這個連線是 我們叫可以通過的

62
00:03:19,880 --> 00:03:24,479
那他就會再建立所謂的第二個連線給server

63
00:03:24,479 --> 00:03:29,979
也就是說client本身可能先跟這個proxy先建連線

64
00:03:29,979 --> 00:03:34,550
然後proxy再到server 這是他的基本的model

65
00:03:34,550 --> 00:03:37,710
也就是說這個

66
00:03:37,710 --> 00:03:41,780
我們說這個data portion of each packet

67
00:03:41,780 --> 00:03:45,250
就是說因為你把連線建起來之後

68
00:03:45,250 --> 00:03:50,849
代表是說 所有的data部分都要把它拿出來

69
00:03:50,849 --> 00:03:54,680
因為要把這個data從一個連線裡面

70
00:03:54,680 --> 00:03:59,410
把它抓出來以後把它塞到第二個連線

71
00:03:59,410 --> 00:04:02,680
也就是說所有的這個每一個封包的data

72
00:04:02,680 --> 00:04:09,180
通通要被萃取出來 要檢查 甚至重新再built

73
00:04:09,180 --> 00:04:13,250
等於要從一個連線搬到另外一個連線的意思

74
00:04:13,250 --> 00:04:18,649
也就是說 要把這個data從原來的封包裡面把他抓出來

75
00:04:18,649 --> 00:04:23,180
經過層層處理之後 要把他送到第二個連線去

76
00:04:23,180 --> 00:04:26,980
這是所謂的proxy該做的事情

77
00:04:26,980 --> 00:04:30,149
那我們說這樣的檢查

78
00:04:30,149 --> 00:04:34,779
他可以非常非常嚴謹的來處理這個封包

79
00:04:34,779 --> 00:04:41,050
也就是說這個proxy的firewall它有非常高度的安全性

80
00:04:41,050 --> 00:04:43,910
而且我們講非常的慢

81
00:04:43,910 --> 00:04:49,180
因為他要把連線上面的每一個資料

82
00:04:49,180 --> 00:04:52,750
每一個data、每一個內容通通把它拿出來

83
00:04:52,750 --> 00:04:57,579
然後做檢查 然後再把它塞到另外一個連線的封包裡面去

84
00:04:57,579 --> 00:04:58,980
那這個檢查的過程當中

85
00:04:58,980 --> 00:05:02,509
因為所有的內容都可以看、都可以檢查

86
00:05:02,509 --> 00:05:08,110
所以我們說他有非常高的這個安全度 very secure

87
00:05:08,110 --> 00:05:12,180
但是也相對的 因為這樣處理的話

88
00:05:12,180 --> 00:05:13,779
他要花掉更多的資源

89
00:05:13,779 --> 00:05:17,209
我們說他的速度通常會比較慢一點點

90
00:05:17,209 --> 00:05:21,680
我們再來看說 那這種proxy本身

91
00:05:21,680 --> 00:05:24,949
因為他是做到application layer

92
00:05:27,949 --> 00:05:27,949
所以他就必須去懂這個application layer的這個應用

93
00:05:27,980 --> 00:05:32,110
就是proxy本身她必須了解這個application layer

94
00:05:32,110 --> 00:05:36,149
就不同的application有不同的protocol

95
00:05:36,149 --> 00:05:38,410
有不同的應用有不同的自己的這個協議

96
00:05:38,410 --> 00:05:41,149
所以變成說這個proxy本身

97
00:05:41,149 --> 00:05:45,709
要去了解每一個他想要所謂的代理的這個應用

98
00:05:45,709 --> 00:05:50,910
如果說未來有一個新的protocol重新被開發出來

99
00:05:50,910 --> 00:05:54,350
那我們就必須有新的proxy的意思

100
00:05:54,350 --> 00:05:58,410
也就是說application A的這個proxy

101
00:05:58,410 --> 00:06:02,050
不能給application B來使用

102
00:06:02,050 --> 00:06:05,279
因為不同的application他的protocol是不一樣的

103
00:06:05,279 --> 00:06:08,779
也就如果有新的protocol被開發出來

104
00:06:08,779 --> 00:06:10,779
那我們就必須有新的proxy

105
00:06:10,779 --> 00:06:14,480
這個是他的一個等於說將來在擴充上面

106
00:06:14,480 --> 00:06:15,880
會碰到一個困難

107
00:06:15,880 --> 00:06:19,009
因為不同的application會有不同的這個應用

108
00:06:19,009 --> 00:06:21,810
我們來看譬如說像

109
00:06:21,810 --> 00:06:25,480
常看的像Web Proxy Server 就是網站

110
00:06:25,480 --> 00:06:27,509
我們會有很多很多網站

111
00:06:27,509 --> 00:06:31,110
那每一個這個Web都可以有一個Proxy server

112
00:06:31,110 --> 00:06:33,250
代表說我們本來應該連到網站的

113
00:06:33,250 --> 00:06:37,350
網站的伺服器我們可能就連到這個proxy

114
00:06:37,350 --> 00:06:41,079
那或者是說假設有其他的應用

115
00:06:41,079 --> 00:06:43,279
我們叫做Application Proxy Server

116
00:06:43,279 --> 00:06:46,279
不同的應用可以有不同的proxy

117
00:06:46,279 --> 00:06:47,980
譬如說mail server

118
00:06:47,980 --> 00:06:52,880
他就是一個application gateway的一個例子

119
00:06:52,880 --> 00:06:55,009
也就是通常我們在寄mail的時候

120
00:06:55,009 --> 00:06:57,250
我們常常先寄給mail server

121
00:06:57,250 --> 00:06:59,480
那mail server再幫我們轉寄到

122
00:06:59,480 --> 00:07:03,550
真正的所謂的使用者的這個信箱裡頭去

123
00:07:03,550 --> 00:07:08,880
那這個application proxy我們說他就是

124
00:07:08,880 --> 00:07:11,880
防火牆裡面的第二代的這個技術

125
00:07:11,880 --> 00:07:15,079
第二代的技術本身我們說

126
00:07:15,079 --> 00:07:21,209
他是幫client跟server之間建連線

127
00:07:21,209 --> 00:07:26,149
也就是我們會替這個client跟server建立這個連線

128
00:07:26,149 --> 00:07:29,709
那當然他沒有非常的有彈性

129
00:07:29,709 --> 00:07:33,610
我們說not flexible是因為說這個proxy本身

130
00:07:33,610 --> 00:07:37,779
他必須懂得這個所謂的application

131
00:07:37,779 --> 00:07:41,180
那如果有新的application protocol出來的時候

132
00:07:41,180 --> 00:07:43,209
我們就要重新再開發一個

133
00:07:43,209 --> 00:07:44,000
所謂的新的這個proxy Subtitles End: mo.dbxdb.com

