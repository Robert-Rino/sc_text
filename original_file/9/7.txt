2
00:00:00,270 --> 00:00:02,700
好那接下來我們來介紹說

3
00:00:02,700 --> 00:00:06,820
那我怎麼換那個MAC位址

4
00:00:06,820 --> 00:00:10,020
就是我們叫做Neighbor Solicitation

5
00:00:10,020 --> 00:00:12,750
就是我怎麼去找neighbor的MAC位址

6
00:00:12,750 --> 00:00:15,420
你可能知道Neighbor的IP

7
00:00:15,420 --> 00:00:17,870
但是你不知道那個Neighbor的MAC位址

8
00:00:17,870 --> 00:00:20,500
就是說我們這樣沒辦法跟他溝通嘛

9
00:00:20,500 --> 00:00:23,370
因為你要溝通的話一定要用對方的MAC位址

10
00:00:23,370 --> 00:00:25,320
網卡的位址 才有辦法送給他

11
00:00:25,320 --> 00:00:27,850
可是呢你有對方的IPv6的位址

12
00:00:27,850 --> 00:00:28,970
可是你沒有MAC位址

13
00:00:28,970 --> 00:00:30,550
所以我們必須用一個方法

14
00:00:30,550 --> 00:00:33,350
這個方法就叫做Neighbor Solicitation

15
00:00:33,350 --> 00:00:36,370
我們丟一個封包 就是ICMP

16
00:00:36,370 --> 00:00:38,470
他的type呢是135

17
00:00:38,470 --> 00:00:41,620
我們這邊就會把target的address

18
00:00:41,620 --> 00:00:46,770
就是我們希望邀請的對方的IPv6放進來

19
00:00:46,770 --> 00:00:50,650
這是IPv6的位址 用ICMP這個封包呢

20
00:00:50,650 --> 00:00:52,800
就丟到這個網路上面去

21
00:00:52,800 --> 00:00:57,500
那每個這個Neighbor收到之後呢

22
00:00:57,500 --> 00:01:01,500
他就去檢查說 咦這個IPv6位址是不是他的

23
00:01:01,500 --> 00:01:04,450
如果是他的 他就要回的意思

24
00:01:04,450 --> 00:01:06,099
回的時候就會把他的MAC帶回來

25
00:01:07,099 --> 00:01:09,870
帶回來 好那這個時候因為

26
00:01:09,870 --> 00:01:12,599
他是一個邀請的這個封包

27
00:01:12,599 --> 00:01:20,250
所以邀請的對象 我們剛剛提到就是FF02::1

28
00:01:20,250 --> 00:01:21,550
所以這邊看很多很多0

29
00:01:21,550 --> 00:01:25,170
事實上他可以用兩個連續的冒號連在一起

30
00:01:25,170 --> 00:01:26,349
好也就是把它丟到這邊去

31
00:01:27,349 --> 00:01:30,800
這個位址呢就代表說 這是要邀請

32
00:01:30,800 --> 00:01:32,920
邀請這個所謂的Neighbor

33
00:01:32,920 --> 00:01:34,550
那Neighbor就會去檢查說

34
00:01:34,550 --> 00:01:37,000
咦這個IPv6位址呢是不是他自己的

35
00:01:38,000 --> 00:01:40,920
是不是他自己的 因為如果是的話呢

36
00:01:40,920 --> 00:01:43,500
他就要把他的MAC帶回來

37
00:01:43,500 --> 00:01:44,900
那MAC帶回來就帶在這邊

38
00:01:44,900 --> 00:01:47,770
這就是他回覆的 相當於說

39
00:01:47,770 --> 00:01:52,500
有這個一問 然後就一答

40
00:01:52,500 --> 00:01:56,420
就是先問然後再回來 那問的時候呢

41
00:01:56,420 --> 00:02:00,400
等於說這邊就是IP位址 IPv6

42
00:02:00,400 --> 00:02:02,000
好阿這邊回的呢就是回這個MAC

43
00:02:04,000 --> 00:02:06,599
所以這樣呢就是相當於我們以前

44
00:02:06,599 --> 00:02:08,069
在IPv4網路裡面

45
00:02:09,069 --> 00:02:12,770
所謂的ARP 就是A-R-P的功能就可以做起來

46
00:02:12,770 --> 00:02:16,620
好那我們再來介紹說IPv6裡面呢

47
00:02:16,620 --> 00:02:20,150
還有兩個很重要的所謂的欄位

48
00:02:20,150 --> 00:02:21,849
特製一個叫做Flow

49
00:02:21,849 --> 00:02:24,669
那Flow本身呢 我們說

50
00:02:24,669 --> 00:02:27,650
甚麼叫一個Flow Label 或者甚麼叫一個Flow

51
00:02:27,650 --> 00:02:29,750
Flow一般我們叫做流量

52
00:02:29,750 --> 00:02:32,220
那流量本身呢 就是相當於說

53
00:02:32,220 --> 00:02:33,250
一個資料流 一個Flow

54
00:02:34,250 --> 00:02:36,349
Flow就是一系列的封包

55
00:02:36,349 --> 00:02:40,849
那他可能是在兩個電腦之間 我們講

56
00:02:40,849 --> 00:02:43,169
要送給特定的一個Destination

57
00:02:43,169 --> 00:02:46,599
可能是Unicast也有可能是Multicast

58
00:02:46,599 --> 00:02:49,569
也就是說我們假設讓兩台電腦之間

59
00:02:49,569 --> 00:02:52,099
那他們送的就是所有的封包

60
00:02:52,099 --> 00:02:54,099
這個都可以叫做一個Flow

61
00:02:54,099 --> 00:02:56,020
那也有可能是比如說 我們做Multicast

62
00:02:56,020 --> 00:02:58,550
就變成他送給兩個 那他們中間

63
00:02:58,550 --> 00:03:01,699
這些封包的集合 就叫做一個Flow

64
00:03:01,699 --> 00:03:05,250
每一個Flow呢 我們會給他一個標籤

65
00:03:05,250 --> 00:03:09,300
叫做Flow Label 那在這個IPv6的Header裡面呢

66
00:03:09,300 --> 00:03:12,650
我們一個特定的欄位 就是這個24個bits

67
00:03:12,650 --> 00:03:14,569
我們故意放在Header裡面

68
00:03:14,569 --> 00:03:17,419
也就是說我們的Router 如果看到說

69
00:03:17,419 --> 00:03:18,750
咦這個有一個Flow Table

70
00:03:18,750 --> 00:03:21,720
他就可能知道說這個Flow要怎麼處理他

71
00:03:21,720 --> 00:03:24,370
他就不用看這個後面的IP位址了

72
00:03:24,370 --> 00:03:26,870
就是說Router在處理封包的時候

73
00:03:26,870 --> 00:03:29,949
要看很多欄位 就會變慢

74
00:03:29,949 --> 00:03:31,520
那如果只看這個Flow Label

75
00:03:31,520 --> 00:03:33,069
他就知道說這個Flow要做甚麼

76
00:03:34,069 --> 00:03:36,120
阿就可以做得很快 可以加快那個

77
00:03:37,120 --> 00:03:39,569
Router處理封包的速度啦

78
00:03:39,569 --> 00:03:42,169
好那我們再來看說 那如果有一個

79
00:03:42,169 --> 00:03:44,169
Flow Label 等於說這個封包呢

80
00:03:44,169 --> 00:03:46,069
給他一個標籤 代表他是哪一個Flow

81
00:03:47,069 --> 00:03:49,520
然後接下來就可以說那我要可以這個

82
00:03:49,520 --> 00:03:52,169
Flow做甚麼事呢?所以我們叫做

83
00:03:53,169 --> 00:03:54,870
Real-time的Support 也就是

84
00:03:54,870 --> 00:03:58,250
IPv6本身呢 可以支援所謂的即時通訊

85
00:03:58,250 --> 00:04:01,900
針對比較重要的流量 比如說影音

86
00:04:01,900 --> 00:04:04,220
需要這個即時性的這個流量

87
00:04:04,220 --> 00:04:06,069
他可以做特別的處理 包含說

88
00:04:07,069 --> 00:04:09,819
像我們可以有一些叫Real-time Flow

89
00:04:09,819 --> 00:04:11,900
Real-time Flow的意思就是說

90
00:04:11,900 --> 00:04:15,449
像這個地方是一個Router的一個簡圖

91
00:04:15,449 --> 00:04:17,720
我們的Router裡面會有很多port

92
00:04:17,720 --> 00:04:20,069
那每一個port呢他會有一些queue

93
00:04:21,069 --> 00:04:24,819
也就是說我們假設這邊是一個路由器很大

94
00:04:24,819 --> 00:04:27,269
那他會有很多這個 很多接口嘛

95
00:04:28,269 --> 00:04:32,120
那每一個接口 就相當於一個這樣子的設計

96
00:04:32,120 --> 00:04:35,069
相當於這個每一個接口呢 都會有很多queue的意思

97
00:04:36,069 --> 00:04:38,819
這是同一個接口的 這樣子

98
00:04:38,819 --> 00:04:42,170
那Router本身 封包進來的時候呢

99
00:04:42,170 --> 00:04:43,199
他就可以根據不同的Flow

100
00:04:44,199 --> 00:04:47,800
不同的Flow給他放在不同的queue

101
00:04:47,800 --> 00:04:49,300
然後這個不同的queue呢

102
00:04:49,300 --> 00:04:52,050
他有不同的服務品質 叫做QoS

103
00:04:52,050 --> 00:04:54,269
我們會有一個很重要的叫做Scheduler

104
00:04:54,269 --> 00:04:56,170
一般叫做排程 在排程本身

105
00:04:57,170 --> 00:05:01,519
如果他把這個封包 從這個queue裡面呢

106
00:05:01,519 --> 00:05:04,319
ㄧ個ㄧ個一個ㄧ個 輪流送

107
00:05:04,319 --> 00:05:06,850
我們ㄧ般叫Round-Robin 就是輪流

108
00:05:06,850 --> 00:05:08,100
那大家分不出重要性來

109
00:05:09,100 --> 00:05:11,819
但如果說我們用priority queue

110
00:05:11,819 --> 00:05:14,920
就是說我先把上面這個封包呢

111
00:05:14,920 --> 00:05:17,500
這個流量先出去 上面的queue呢

112
00:05:17,500 --> 00:05:21,000
一定要先送完 才能送下面的queue

113
00:05:21,000 --> 00:05:22,370
那這個上面的queue呢

114
00:05:22,370 --> 00:05:24,319
我們說priority就比較高囉

115
00:05:24,319 --> 00:05:26,800
那這個就有所謂的priority就出來了

116
00:05:26,800 --> 00:05:29,500
就如果我們有ㄧ些Real-time的flow呢

117
00:05:29,500 --> 00:05:33,519
是送到這裡來 然後呢他會先出去

118
00:05:33,519 --> 00:05:36,519
那送到下面這邊來的呢 他就會在這邊

119
00:05:36,519 --> 00:05:38,350
等於說他在這邊會queue比較久

120
00:05:38,350 --> 00:05:40,720
因為要等上面的送完

121
00:05:40,720 --> 00:05:42,920
那這個叫做priority queue

122
00:05:42,920 --> 00:05:46,399
那在另外一個就是說 另外一個做法 包含說

123
00:05:46,399 --> 00:05:53,920
好那如果說我不想讓上面的全部送完才送下面

124
00:05:53,920 --> 00:05:55,699
好那這樣的話我有甚麼做法

125
00:05:55,699 --> 00:05:57,620
我們還有很多種做法包含說

126
00:05:57,620 --> 00:06:01,399
我先送這裡 比如說送三個封包

127
00:06:01,399 --> 00:06:05,269
這邊送兩個封包 這裡送ㄧ個封包

128
00:06:05,269 --> 00:06:07,370
這裡送ㄧ個封包 這裡送ㄧ個

129
00:06:07,370 --> 00:06:09,420
也就是說我們送封包的比例

130
00:06:09,420 --> 00:06:12,269
可以所謂的三比二比一比一比一

131
00:06:12,269 --> 00:06:15,500
這是一個做法 那或者任何比例啦

132
00:06:15,500 --> 00:06:17,970
那這個叫做所謂的Weighted fair queuing

133
00:06:17,970 --> 00:06:21,149
就是說我們可以根據我們實際上的需要

134
00:06:21,149 --> 00:06:24,250
不同的Flow給他出去的這個頻寬

135
00:06:24,250 --> 00:06:26,600
可以有一個比例的意思

136
00:06:26,600 --> 00:06:28,569
阿這個比例如果通通都ㄧ樣

137
00:06:28,569 --> 00:06:30,170
就是Round-Robin

138
00:06:30,170 --> 00:06:33,250
那這很高很高很高 相當於無限大

139
00:06:33,250 --> 00:06:36,519
就是priority 那如果這個特定的比例

140
00:06:36,519 --> 00:06:38,850
ㄧ般我們叫做Weighted fair queuing

141
00:06:38,850 --> 00:06:43,720
ㄧ般叫做Weighted-fair-queuing的一個做法

142
00:06:43,720 --> 00:06:47,019
就是公平 那公平本身有一個比例的意思啦

143
00:06:47,019 --> 00:06:48,750
Weighted fair queuing這樣子 所以

144
00:06:48,750 --> 00:06:52,069
如果是IPv6本身有這個Flow Level的話

145
00:06:52,069 --> 00:06:55,769
他其實就可以提供一個說 那你是哪一個Flow

146
00:06:55,769 --> 00:06:59,069
因為Flow就可以很快速的就辨別

147
00:06:59,069 --> 00:07:01,819
所以流量進來就可以放到不同的地方去

148
00:07:01,819 --> 00:07:04,500
然後再加上他有priority 我們知道說

149
00:07:04,500 --> 00:07:06,819
有priority的這個 這個欄位嘛

150
00:07:06,819 --> 00:07:08,399
所以我們就可以等於說

151
00:07:08,399 --> 00:07:12,300
阿這是哪一個Flow阿他的優先權是多大

152
00:07:12,300 --> 00:07:15,199
那在Router裡面呢 他就可以這樣的設計

153
00:07:15,199 --> 00:07:17,819
就可以讓這個服務品質嘛

154
00:07:17,819 --> 00:07:19,550
就可以做到更好一點

155
00:07:20,550 --> 00:07:25,250
好那接下來我們來介紹security的這一部分

156
00:07:25,250 --> 00:07:28,000
那我們說IPv6的security呢 到底怎麼做?

157
00:07:29,000 --> 00:07:31,220
那我們知道說security裡面

158
00:07:31,220 --> 00:07:32,920
基本上有兩個最重要的功能

159
00:07:32,920 --> 00:07:34,870
一個是認證 一個是加密

160
00:07:34,870 --> 00:07:37,670
就是認證本身就是說 阿我要確認你的

161
00:07:37,670 --> 00:07:40,370
身份對不對我才要把資料丟給你

162
00:07:40,370 --> 00:07:44,370
如果身分不對 等於說你是來騙我的

163
00:07:44,370 --> 00:07:45,819
那我知道當然不能給你

164
00:07:45,819 --> 00:07:47,720
所以認證是很重要的

165
00:07:47,720 --> 00:07:50,899
阿第二個就是說 加密就是說

166
00:07:50,899 --> 00:07:53,069
加密就是說我把資料做加密之後

167
00:07:53,069 --> 00:07:55,550
變成說你可能拿得到 可是你看不懂

168
00:07:55,550 --> 00:07:59,519
認證是說你是假身分 你來騙我的資料

169
00:07:59,519 --> 00:08:02,600
認證讓你騙不了 加密讓你看不懂

170
00:08:02,600 --> 00:08:05,720
因為你沒有那個key是看不懂的

171
00:08:05,720 --> 00:08:09,750
那我們說 所有的IPv6的這個實作呢

172
00:08:09,750 --> 00:08:14,199
都要求他要support認證跟加密這兩個Header

173
00:08:14,199 --> 00:08:17,050
我們注意到 我們剛剛有介紹說

174
00:08:17,050 --> 00:08:18,699
他是有兩個Header

175
00:08:18,699 --> 00:08:20,720
ㄧ個叫做Authentication Header

176
00:08:20,720 --> 00:08:22,000
ㄧ個叫做Encryption Header

177
00:08:23,000 --> 00:08:26,000
這兩個都是變成Extention Header啦

178
00:08:26,000 --> 00:08:28,269
變成說這個Header呢變成是

179
00:08:28,269 --> 00:08:29,250
你要的時候才用到

180
00:08:30,250 --> 00:08:31,949
那你不需要的時候呢

181
00:08:31,949 --> 00:08:33,870
這個Header都不用在裡面

182
00:08:33,870 --> 00:08:37,149
也有說我們IPv6是讓他更精簡嘛

183
00:08:37,149 --> 00:08:39,419
所以如果我們需要做認證

184
00:08:39,419 --> 00:08:41,669
就加Authentication Header

185
00:08:41,669 --> 00:08:45,950
那如果需要做加密 就用所謂的加密的Header

186
00:08:45,950 --> 00:08:47,820
如果都不需要 就不用

187
00:08:47,820 --> 00:08:50,250
然後他們又把這兩個Header把它分開來

188
00:08:51,250 --> 00:08:53,850
我們說 把他separate

189
00:08:53,850 --> 00:08:55,350
這兩個分開來就是說

190
00:08:55,350 --> 00:08:57,919
那為甚麼不合在一起變成兩個Header呢

191
00:08:57,919 --> 00:09:00,649
因為這是兩個功能 有時候我要認證

192
00:09:00,649 --> 00:09:01,000
但是我不要加密

193
00:09:02,000 --> 00:09:04,649
有時候呢我不要認證 可是我要加密

194
00:09:04,649 --> 00:09:06,620
這兩個是獨立的功能啦

195
00:09:06,620 --> 00:09:08,250
所以把它獨立成兩個Header

196
00:09:09,250 --> 00:09:12,169
也就是如果說我們不需要加密的時候

197
00:09:12,169 --> 00:09:13,000
我就不要這個Encryption Header

198
00:09:14,000 --> 00:09:16,149
或者說 不可以加密的時候

199
00:09:16,149 --> 00:09:17,000
我也不用這個Encryption Header

200
00:09:18,000 --> 00:09:20,450
讓他更有彈性 變成說這兩個Header

201
00:09:20,450 --> 00:09:21,019
其實是獨立的

202
00:09:22,019 --> 00:09:24,850
你需要認證 就用認證Header

203
00:09:24,850 --> 00:09:27,169
你需要加密 就用加密的Header

204
00:09:27,169 --> 00:09:29,299
但是如果你認證或加密呢

205
00:09:29,299 --> 00:09:33,399
都會用一個key 我們叫所謂的鑰匙、金鑰

206
00:09:33,399 --> 00:09:35,720
這個key呢就要送給對方

207
00:09:35,720 --> 00:09:39,669
所以他有一個叫Key Distribution的protocol

208
00:09:39,669 --> 00:09:43,500
因為你加密之後 有時候你必須把這個key

209
00:09:43,500 --> 00:09:46,899
加密的這個鑰匙送給對方 對方才能解密嘛

210
00:09:46,899 --> 00:09:50,899
因為中間的人看不懂 可是你那個真正的目的地

211
00:09:50,899 --> 00:09:53,220
他一定要看得懂 所以ㄧ定要

212
00:09:53,220 --> 00:09:56,600
有加密就有解密 阿你加密呢用了什麼key

213
00:09:56,600 --> 00:09:57,049
解密就要用那個key

214
00:09:58,049 --> 00:10:00,899
他大概就是所謂的對稱式的加密啦

215
00:10:00,899 --> 00:10:03,049
那當然事實上在資訊安全裡面啦

216
00:10:04,049 --> 00:10:06,620
有所謂的非對稱性的加密

217
00:10:06,620 --> 00:10:07,850
ㄧ般叫做public key

218
00:10:07,850 --> 00:10:10,700
那當然就不用把key交給對方

219
00:10:10,700 --> 00:10:12,419
因為你只有他的public key

220
00:10:12,419 --> 00:10:15,220
不過這個地方 我們就暫時先不提

221
00:10:15,220 --> 00:10:16,370
好那我們就來看

222
00:10:16,370 --> 00:10:18,570
這個所謂的Authentication Header

223
00:10:18,570 --> 00:10:21,450
就是認證的Header長甚麼樣子

224
00:10:21,450 --> 00:10:22,120
那認證的Headers呢

225
00:10:23,120 --> 00:10:25,419
當然我們會有一個所謂的

226
00:10:25,419 --> 00:10:28,750
Destination的Address 對方的IP位址

227
00:10:28,750 --> 00:10:32,120
然後會有ㄧ些加密的參數的index

228
00:10:33,120 --> 00:10:34,899
就是這些都是加密用的

229
00:10:34,899 --> 00:10:36,370
我們把這個加密的

230
00:10:36,370 --> 00:10:37,769
對不起這是認證用的

231
00:10:37,769 --> 00:10:40,000
我們把這個認證的這個資料呢

232
00:10:40,000 --> 00:10:42,250
就放在這個Header上面

233
00:10:42,250 --> 00:10:45,720
讓對方透過這個東西做身分認證

234
00:10:45,720 --> 00:10:48,120
就是這個Header就是要作身分認證

235
00:10:48,120 --> 00:10:51,299
那身分認證裡面呢 採用到的這個演算法

236
00:10:51,299 --> 00:10:57,070
包含說MD5 這是用的這個身分認證的演算法的

237
00:10:57,070 --> 00:10:59,200
這個常用的ㄧ個方法

238
00:10:59,200 --> 00:11:02,220
好那加密的部分呢 我們相當於

239
00:11:02,220 --> 00:11:04,669
用一個所謂的  Encapsulating的

240
00:11:04,669 --> 00:11:08,419
Security Payload 就是他 這個是加密過的

241
00:11:08,419 --> 00:11:10,750
這個資料 那我們也是一樣

242
00:11:10,750 --> 00:11:14,570
會有一個相同的Header這個是

243
00:11:14,570 --> 00:11:18,019
放加密相關的這個參數 放在這裡面

244
00:11:18,019 --> 00:11:22,549
然後透過這個 所謂的加密的Header

245
00:11:22,549 --> 00:11:25,769
把加密的資料放在這個地方

246
00:11:25,769 --> 00:11:28,620
把參數放在這個地方 然後跟對方溝通

247
00:11:28,620 --> 00:11:30,370
那對方看到這個資料之後呢

248
00:11:30,370 --> 00:11:32,250
他就知道說 怎麼去解密

249
00:11:32,250 --> 00:11:34,120
知道說這個資料在哪裡

250
00:11:34,120 --> 00:11:35,000
比如說加密的資料在什麼地方 Subtitles End: mo.dbxdb.com

